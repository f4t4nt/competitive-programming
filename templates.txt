#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using ull = unsigned long long;
using cd = complex<long double>;
using ld = long double;
using ch = char;
using str = string;

#include <bits/extc++.h>
using namespace __gnu_pbds;

using indexed_set = tree<
    pair<ll, ll>,
    null_type,
    less<pair<ll, ll>>,
    rb_tree_tag,
    tree_order_statistics_node_update
>;

#pragma GCC target("popcnt,lzcnt")

#define pb push_back
#define elif else if
#define sz(C) (ll) C.size()
#define all(C) C.begin(), C.end()
#define flip(C) reverse(all(C))
#define ssort(C) sort(all(C))
#define rsort(C) sort(all(C), greater<>())

#define FOR(x, e) for(ll x = 0; x < (ll) e; x++)
#define FORR(x, e) for(ll x = (ll) e - 1; x >= 0; x--)
#define FOB(x, b, e) for(auto x = b; x < e; x++)
#define FORE(x, C) for(auto &x : C)

// Run -> Add configuration... -> in launch.json:
// "program": "${fileDirname}/${fileBasenameNoExtension}",
// "preLaunchTask": "C/C++: g++ build active file",

//--------------------------------------------------

// clockwise angle from (x1, y1) to (x0, y0) to (x2, y2)
ld angle(ld x1, ld y1, ld x0, ld y0, ld x2, ld y2) {
    ld dot = (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0),
        det = (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0),
        rv = atan2(det, dot);
    if (rv < 0) {
        rv += 2 * M_PI;
    }
    return rv;
}

//--------------------------------------------------

void bellman_ford(ll v, vector<tuple<ll, ll, ll>> &edges, vector<ll> &dist) {
    ll n = sz(dist);
    FOR (i, n) {
        dist[i] = INF;
    }
    dist[v] = 0;
    FOR (i, n - 1) {
        for (auto [a, b, w] : edges) {
            if (dist[a] != INF && dist[a] + w < dist[b]) {
                dist[b] = dist[a] + w;
            }
        }
    }
}

void dijkstra(ll v0, vector<vector<pair<ll, ll>>> &adj, vector<ll> &dist) {
    std::priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<>> pq;
    pq.push({0, v0});
    while (!pq.empty()) {
        ll cur_d, u;
        tie(cur_d, u) = pq.top();
        pq.pop();
        if (cur_d > dist[u]) {
            continue;
        }
        FORE (elem, adj[u]) {
            ll v, w;
            tie(v, w) = elem;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}

void floyd_warshall(vector<vector<ll>> &dist) {
    ll n = sz(dist);
    FOR (k, n) {
        FOR (i, n) {
            FOR (j, n) {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
}

//--------------------------------------------------

ll bin_search_find_last(vector<ll> &a) {
        ll lo = 0, hi = sz(a) - 1;
        while (lo < hi) {
            ll mid = (lo + hi + 1) / 2;
            if (valid(mid)) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
}

ll bin_search_find_first(vector<ll> &a) {
    ll lo = 0, hi = sz(a) - 1;
    while (lo < hi) {
        ll mid = (lo + hi) / 2;
        if (valid(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
}

//--------------------------------------------------

struct BIT {
    vector<ll> tree;
    ll n;
    BIT(ll n) : n(n) {
        tree.resize(n + 1);
    }
    void update(ll idx, ll val) {
        idx++;
        while (idx <= n) {
            tree[idx] += val;
            idx += idx & (-idx);
        }
    }
    ll query(ll idx) {
        idx++;
        ll sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= idx & (-idx);
        }
        return sum;
    }
    ll query(ll l, ll r) {
        return query(r) - query(l - 1);
    }
};

struct BIT2d {
    vector<BIT> tree;
    ll n, m;
    BIT2d(ll n, ll m) : n(n), m(m) {
        tree.resize(n + 1, BIT(m));
    }
    void update(ll x, ll y, ll val) {
        x++;
        while (x <= n) {
            tree[x].update(y, val);
            x += x & (-x);
        }
    }
    ll query(ll x, ll y) {
        x++;
        ll sum = 0;
        while (x > 0) {
            sum += tree[x].query(y);
            x -= x & (-x);
        }
        return sum;
    }
    ll query(ll x1, ll y1, ll x2, ll y2) {
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
};

//--------------------------------------------------

pair<ld, ld> get_com(vector<pair<ld, ld>> &poly) {
    ld x = 0, y = 0;
    ld area = 0;
    FOR (i, sz(poly)) {
        ll j = (i + 1) % sz(poly);
        ld a = poly[i].first * poly[j].second - poly[j].first * poly[i].second;
        area += a;
        x += (poly[i].first + poly[j].first) * a;
        y += (poly[i].second + poly[j].second) * a;
    }
    area /= 2;
    x /= 6 * area;
    y /= 6 * area;
    return {x, y};
}

//--------------------------------------------------

struct Point {
    ld x, y;
    Point operator+(Point o) {
        return {x + o.x, y + o.y};
    }
    Point operator-(Point o) {
        return {x - o.x, y - o.y};
    }
    Point operator*(ld k) {
        return {x * k, y * k};
    }
    Point operator/(ld k) {
        return {x / k, y / k};
    }
    ld abs2() {
        return x * x + y * y;
    }
    ld abs_() {
        return sqrt(abs2());
    }
    bool operator==(Point o) {
        return abs(x - o.x) < EPS && abs(y - o.y) < EPS;
    }
    bool operator!=(Point o) {
        return abs(x - o.x) > EPS || abs(y - o.y) > EPS;
    }
};

struct Circle {
    Point c;
    ld r;
    ll id;
    Circle(Point c, ld r, ll id) : c(c), r(r), id(id) {}
    Circle() {}
    bool has(Point &p) {
        return (p - c).abs_() <= r + EPS;
    }
    vector<Point> operator&(Circle &o) {
        if ((c - o.c).abs_() > r + o.r + EPS || (c - o.c).abs_() < abs(r - o.r) - EPS) {
            return {};
        }
        if ((c - o.c).abs_() < EPS && abs(r - o.r) < EPS) {
            return {{c.x + r, c.y}};
        }
        Point sum = o.c + c, diff = o.c - c, perp = {diff.y, -diff.x};
        ld csu = 0.5,
            cdi = (r * r - o.r * o.r) / (2 * diff.abs2()),
            cpe = 0.5 * sqrt(max((ld) 0, 2 * (r * r + o.r * o.r) / (diff.abs2())
                - (r * r - o.r * o.r) * (r * r - o.r * o.r) / (diff.abs2() * diff.abs2()) - 1));
        vector<Point> rv = {sum * csu + diff * cdi + perp * cpe, sum * csu + diff * cdi - perp * cpe};
        return rv;
    }
};

//--------------------------------------------------

vector<pair<ld, ld>> convex_hull(vector<pair<ld, ld>> pts) {
    ssort(pts); // sort points by x-coordinate
    vector<pair<ld, ld>> lo; // lower hull
    for (auto &p : pts) {
        while (sz(lo) >= 2) {
            auto &p1 = lo[sz(lo) - 2];
            auto &p2 = lo[sz(lo) - 1];
            if ((p2.second - p1.second) * (p.first - p2.first) >= (p.second - p2.second) * (p2.first - p1.first)) {
                lo.pop_back();
            } else {
                break;
            }
        }
        lo.pb(p);
    }
    vector<pair<ld, ld>> hi; // upper hull
    for (auto it = pts.rbegin(); it != pts.rend(); it++) {
        auto &p = *it;
        while (sz(hi) >= 2) {
            auto &p1 = hi[sz(hi) - 2];
            auto &p2 = hi[sz(hi) - 1];
            if ((p2.second - p1.second) * (p.first - p2.first) >= (p.second - p2.second) * (p2.first - p1.first)) {
                hi.pop_back();
            } else {
                break;
            }
        }
        hi.pb(p);
    }
    lo.pop_back(); // remove duplicates
    hi.pop_back();
    lo.insert(lo.end(), hi.begin(), hi.end()); // merge lower and upper hulls
    return lo;
}

//--------------------------------------------------

void customsort() {
    vector<ll> x;
    sort(x.begin(), x.end(),
        &[] (const ll &a, const ll &b) -> bool
        { return a < b; });
    // equivalent to regular sort
}

//--------------------------------------------------

struct Edge {
    ll s, t, cap = 0, cost = 0, flow = 0;
};

struct Dinic {
    ll n;
    vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> lvl, ptr;
    queue<ll> q;

    Dinic(ll n, vector<Edge> &edges0) :
        n(n), adj(n), lvl(n), ptr(n) {
        ll i = 0;
        FORE (e, edges0) {
            edges.pb(e);
            edges.pb({e.t, e.s});
            adj[e.s].pb(i++);
            adj[e.t].pb(i++);
        }
    }

    bool bfs(ll s, ll t) {
        lvl.assign(n, -1);
        lvl[s] = 0;
        q.push(s);
        while (!q.empty()) {
            ll v = q.front();
            q.pop();
            FORE (e, adj[v]) {
                ll u = edges[e].t;
                if (lvl[u] != -1 || edges[e].cap <= edges[e].flow) continue;
                lvl[u] = lvl[v] + 1;
                q.push(u);
            }
        }
        return lvl[t] != -1;
    }

    ll dfs(ll v, ll t, ll f) {
        if (v == t || f == 0) return f;
        for (ll &cid = ptr[v]; cid < sz(adj[v]); cid++) {
            ll e = adj[v][cid];
            ll u = edges[e].t;
            if (lvl[v] + 1 != lvl[u]) continue;
            ll pushed = dfs(u, t, min(f, edges[e].cap - edges[e].flow));
            if (pushed) {
                edges[e].flow += pushed;
                edges[e ^ 1].flow -= pushed;
                return pushed;
            }
        }
        return 0;
    }

    ll max_flow(ll s, ll t) {
        ll flow = 0;
        while (bfs(s, t)) {
            ptr.assign(n, 0);
            while (ll pushed = dfs(s, t, INF)) {
                flow += pushed;
            }
        }
        return flow;
    }

    vector<pair<ll, ll>> min_cut(ll s) {
        bfs(s, n - 1);
        vector<pair<ll, ll>> cut;
        FORE (e,edges) {
            if (lvl[e.s] != -1 && lvl[e.t] == -1 && e.cap > 0) {
                cut.pb({e.s, e.t});
            }
        }
        return cut;
    }

    void undo_flow(vector<ll> path, ll f) {
        FOR (i, sz(path) - 1) {
            FORE (e, adj[path[i]]) {
                if (edges[e].t == path[i + 1]) {
                    edges[e].flow -= f;
                    edges[e ^ 1].flow += f;
                    assert(edges[e].flow <= edges[e].cap);
                    assert(edges[e ^ 1].flow <= edges[e ^ 1].cap);
                    break;
                }
            }
        }
    }
};

struct MinCostMaxFlow {
    ll n, m;
    vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> dist, pi, vis;
    vector<pair<ll, ll>> par;

    MinCostMaxFlow(ll n, vector<Edge> &edges0) :
        n(n), m(sz(edges0)), adj(n),
        vis(n), dist(n), pi(n), par(n) {
        ll i = 0;
        FORE (e, edges0) {
            edges.pb(e);
            edges.pb({e.t, e.s});
            adj[e.s].pb(i++);
            adj[e.t].pb(i++);
        }
    }

    void path(ll s) {
        vis.assign(n, false);
        dist.assign(n, INF);
        dist[s] = 0;
        ll di;

        __gnu_pbds::priority_queue<pair<ll, ll>, greater<>> pq;
        vector<decltype(pq)::point_iterator> its(n);
        pq.push({0, s});

        auto relax = [&](ll t, ll e, ll cap, ll cost, ll dir) {
            ll val = di - pi[t] + cost;
            if (cap && val < dist[t]) {
                dist[t] = val;
                par[t] = {e, dir};
                if (its[t] == pq.end()) {
                    its[t] = pq.push({val, t});
                } else {
                    pq.modify(its[t], {val, t});
                }
            }
        };

        while (!pq.empty()) {
            s = pq.top().second;
            pq.pop();
            vis[s] = 1;
            di = dist[s] + pi[s];
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) {
                    relax(t, e, edges[e].cap - edges[e].flow, edges[e].cost, 1);
                }
            }
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) {
                    relax(t, e, edges[e ^ 1].flow, -edges[e ^ 1].cost, 0);
                }
            }
        }

        FOR (i, n) {
            pi[i] = min(pi[i] + dist[i], INF);
        }
    }

    pair<ll, ll> max_flow(ll s, ll t) {
        ll flow = 0, cost = 0;
        while (path(s), vis[t]) {
            ll f = INF;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                f = min(f, r ? edges[p].cap - edges[p].flow : edges[p ^ 1].flow);
            }
            flow += f;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                if (r) edges[p].flow += f;
                else edges[p ^ 1].flow -= f;
            }
        }
        FORE (e, edges) {
            cost += e.flow * e.cost;
        }
        return {flow, cost};
    }

    void set_pi(ll s) { // for negative costs
        pi.assign(n, INF);
        pi[s] = 0;
        ll it = n, ch = 1, v;
        while (ch-- && it--) {
            FOR (i, n) {
                if (pi[i] == INF) continue;
                FORE (e, adj[i]) {
                    if (edges[e].cap && (v = pi[i] + edges[e].cost) < pi[edges[e].t]) {
                        pi[edges[e].t] = v;
                        ch = 1;
                    }
                }
            }
        }
        assert(it >= 0);
    }
};

//--------------------------------------------------

struct DSU {
    ll cnt;
    vector<ll> e;
    DSU(ll n) { e = vector<ll>(n, -1); cnt = n; }
    void reset() { e = vector<ll>(sz(e), -1); cnt = sz(e); }
    ll get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
    bool same_set(ll a, ll b) { return get(a) == get(b); }
    ll size(ll x) { return -e[get(x)]; }
    bool unite(ll x, ll y) {
        x = get(x), y = get(y);
        if (x == y) return false;
        if (e[x] > e[y]) swap(x, y);
        e[x] += e[y]; e[y] = x;
        cnt--;
        return true;
    }
};

//--------------------------------------------------

constexpr ll MOD = 1e9 + 7;

struct Binom {
    ll n;
    vector<ll> fac, ifac;
    Binom(ll n) : n(n) {
        fac.resize(n + 1);
        ifac.resize(n + 1);
        fac[0] = 1;
        FOB (i, 1, n + 1) {
            fac[i] = fac[i - 1] * i % MOD;
        }
        ifac[n] = pow(fac[n], MOD - 2);
        FORR (i, n) {
            ifac[i] = ifac[i + 1] * (i + 1) % MOD;
        }
    }
    ll pow(ll a, ll b) {
        ll rv = 1;
        while (b) {
            if (b & 1) {
                rv = rv * a % MOD;
            }
            a = a * a % MOD;
            b >>= 1;
        }
        return rv;
    }
    ll choose(ll n, ll k) {
        if (k < 0 || k > n) {
            return 0;
        }
        return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;
    }
};

//--------------------------------------------------

// ll n = sz(s), n2 = 2 << (ll) ceil(log2(n));
// vector<cd> a(n2), b(n2);
// ...init a, b...
// fft(a, false);
// fft(b, false);
// FOR (i, n) a[i] *= b[i];
// fft(a, true);

void fft(vector<cd> &a, bool inv) {
    ll n = sz(a);
    for (ll i = 1, j = 0; i < n; i++) {
        ll bit = n >> 1;
        for (; j & bit; bit >>= 1) {
            j ^= bit;
        }
        j ^= bit;
        if (i < j) {
            swap(a[i], a[j]);
        }
    }
    for (ll len = 2; len <= n; len <<= 1) {
        ld ang = 2 * M_PI / len * (inv ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (ll i = 0; i < n; i += len) {
            cd w(1);
            for (ll j = 0; j < len / 2; j++) {
                cd u = a[i + j], v = a[i + j + len / 2] * w;
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }
    if (inv) {
        FORE (x, a) {
            x /= n;
        }
    }
}

//--------------------------------------------------

bool game(auto state, bool alice) {
    if (mem.find(state) != mem.end()) {
        return mem[state];
    }
    FORE (move, all_moves) {
        if (valid(move)) {
            change_state();
            if (!game(state, !alice)) {
                restore_state();
                mem[state] = true;
                return true;
            }
            restore_state();
        }
    }
    mem[state] = false;
    return false;
}

//--------------------------------------------------

ll gauss_jordan(vector<vector<ld>> &A, vector<ld> &b, vector<ld> &x) {
    ll n = A.size(), m = A[0].size();
    vector<vector<ld>> a(n, vector<ld>(m + 1));
    FOR(i, n) {
        FOR(j, m) {
            a[i][j] = A[i][j];
        }
        a[i][m] = b[i];
    }
    vector<ll> where(m, -1);
    for (ll col = 0, row = 0; col < m && row < n; col++) {
        ll sel = row;
        FOB (i, row, n) {
            if (abs(a[i][col]) > abs(a[sel][col])) {
                sel = i;
            }
        }
        if (abs(a[sel][col]) < EPS) {
            continue;
        }
        FOB (i, col, m + 1) {
            swap(a[sel][i], a[row][i]);
        }
        where[col] = row;
        FOR (i, n) {
            if (i != row) {
                ld c = a[i][col] / a[row][col];
                FOB (j, col, m + 1) {
                    a[i][j] -= a[row][j] * c;
                }
            }
        }
        row++;
    }
    x.assign(m, 0);
    FOR (i, m) {
        if (where[i] != -1) {
            x[i] = a[where[i]][m] / a[where[i]][i];
        }
    }
    FOR (i, n) {
        ld sum = 0;
        FOR (j, m) {
            sum += a[i][j] * x[j];
        }
        if (abs(sum - a[i][m]) > EPS) { // may need to change for modulo
            return 0;
        }
    }
    FOR (i, m) {
        if (where[i] == -1) {
            return INF;
        }
    }
    return 1;
}

int gauss_jordan_binary(
    vector<bitset<MAXN>> A,
    bitset<MAXN> &b,
    bitset<MAXN> &x,
    int n,
    int m
) {
    FOR (i, n) {
        A[i][m] = b[i];
    }
    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; col++) {
        FOB (i, row, n) {
            if (A[i][col] != 0) {
                swap(A[i], A[row]);
                break;
            }
        }
        if (A[row][col] == 0) {
            continue;
        }
        where[col] = row;
        FOR (i, n) {
            if (i != row && A[i][col] != 0) {
                A[i] ^= A[row];
            }
        }
        row++;
    }
    x = bitset<MAXN>(0);
    FOR (i, m) {
        if (where[i] != -1) {
            x[i] = A[where[i]][m] / A[where[i]][i];
        }
    }
    FOR (i, n) {
        int sum = 0;
        FOR (j, m) {
            sum += A[i][j] * x[j];
        }
        if (sum != A[i][m]) {
            return 0;
        }
    }
    FOR (i, m) {
        if (where[i] == -1) {
            return INF;
        }
    }
    return 1;
}

//--------------------------------------------------

ll gcd(ll a, ll b) {
    if (a == 0) return b;
    return gcd(b % a, a);
}

// a * x + b * y = gcd(a, b)

pair<ll, ll> bezout(ll a, ll b) {
    if (a == 0) return {0, 1};
    auto [x, y] = bezout(b % a, a);
    return {y - (b / a) * x, x};
}

// x % m == a, x % n == b
// x % lcm(m, n) = -(a * v * n + b * u * m) / gcd(m, n)

ll crt(ll m, ll n, ll a, ll b) {
    ll g = gcd(m, n);
    if (a % g != b % g) return -1;
    ll lcm = m * n / g;
    auto [u, v] = bezout(m / g, n / g);
    ll k = (b - a) / g;
    ll x = (a + m * k * u) % lcm;
    if (x < 0) x += lcm;
    return x;
}

//--------------------------------------------------

struct LCA_Tree {
    vector<vector<ll>> parent, adj;
    vector<ll> pre, post, depth;
    ll n, timer;
    LCA_Tree(ll &n0, vector<vector<ll>> &adj0) {
        n = n0;
        timer = 0;
        pre = vector<ll>(n), post = pre, depth = pre;
        parent = vector<vector<ll>>(n, vector<ll>(30));
        adj = adj0;
        dfs(0, 0, 0);
        gen();
    }
    void dfs(ll node, ll par, ll d) {
        pre[node] = timer++;
        depth[node] = d;
        parent[node][0] = par;
        FORE (child, adj[node]) {
            if (child != par) {
                dfs(child, node, d + 1);
            }
        }
        post[node] = timer++;
    }
    void gen() {
        FOR (i, 29) {
            FOR (j, n) {
                parent[j][i + 1] = parent[parent[j][i]][i];
            }
        }
    }
    bool is_anc(ll u, ll v) {
        return pre[u] <= pre[v] && post[u] >= post[v];
    }
    ll lca(ll u, ll v) {
        if (is_anc(u, v)) return u;
        if (is_anc(v, u)) return v;
        FORR (i, 30) {
            if (!is_anc(parent[u][i], v)) {
                u = parent[u][i];
            }
        }
        return parent[u][0];
    }
    ll dist(ll u, ll v) {
        return depth[u] + depth[v] - 2 * depth[lca(u, v)];
    }
    bool disjoint(vector<pair<ll, ll>> paths) {
        vector<pair<ll, ll>> p;
        FORE (path, paths) {
            ll u, v;
            tie(u, v) = path;
            ll w = lca(u, v);
            p.pb({w, u});
            p.pb({w, v});
        }
        FOR (i, sz(p)) {
            FOR (j, i - i % 2) {
                if (!(lca(p[i].second, p[j].first) != p[j].first ||
                    lca(p[j].second, p[i].first) != p[i].first))
                {
                    return false;
                }
            }
        }
        return true;
    }
};

//--------------------------------------------------

pair<ll, ll> manacher(str &s) {
    str t = "$#";
    FORE (c, s) {
        t += c;
        t += '#';
    }
    ll n = sz(t);
    ll center = 0, max_rad = -1, rad;
    vector<ll> p(n);
    FOR (i, n) {
        if (i <= max_rad) {
            rad = min(p[2 * center - i], max_rad - i);
        } else {
            rad = 0;
        }
        while (i - rad - 1 >= 0 && i + rad + 1 < n && t[i - rad - 1] == t[i + rad + 1]) {
            rad++;
        }
        p[i] = rad;
        if (i + rad > max_rad) {
            center = i;
            max_rad = i + rad;
        }
    }
    ll len = 0, idx = 0;
    FOR (i, n) {
        if (p[i] > len) {
            len = p[i];
            idx = i;
        }
    }
    return {len, (idx - len) / 2};
}

//--------------------------------------------------

struct Matrix {
    vector<vector<ll>> mat;
    ll n, m;
    Matrix(ll n, ll m) : n(n), m(m) {
        mat.resize(n, vector<ll>(m));
    }
    Matrix operator*(const Matrix &other) const {
        Matrix rv(n, other.m);
        FOR(i, n) {
            FOR(j, other.m) {
                FOR(k, m) {
                    rv.mat[i][j] += mat[i][k] * other.mat[k][j];
                    rv.mat[i][j] %= MOD;
                }
            }
        }
        return rv;
    }
    Matrix operator^(ll p) const {
        Matrix rv(n, n);
        FOR(i, n) {
            rv.mat[i][i] = 1;
        }
        Matrix a = *this;
        while (p) {
            if (p & 1) {
                rv = rv * a;
            }
            a = a * a;
            p >>= 1;
        }
        return rv;
    }
    // min dist
    Matrix operator*(const Matrix &other) const {
        Matrix rv(n, other.m);
        rv.mat.assign(n, vector<ll>(other.m, INF));
        FOR(i, n) {
            FOR(j, other.m) {
                FOR(k, m) {
                    rv.mat[i][j] = min(rv.mat[i][j], mat[i][k] + other.mat[k][j]);
                }
            }
        }
        return rv;
    }

    Matrix operator^(ll p) const {
        Matrix rv(n, n);
        rv.mat.assign(n, vector<ll>(n, INF));
        FOR (i, n) {
            rv.mat[i][i] = 0;
        }
        Matrix a = *this;
        while (p) {
            if (p & 1) {
                rv = rv * a;
            }
            a = a * a;
            p >>= 1;
        }
        return rv;
    }
};

//--------------------------------------------------

ll pow(ll x, ll p) {
    ll rv = 1;
    while(p) {
        if(p & 1) rv *= x;
        x *= x;
        p >>= 1;
    }
    return rv;
}

//--------------------------------------------------

struct SCCs {
    ll n, idx, scc_cnt;
    vector<vector<ll>> adj, adj_scc;
    vector<ll> ord, low, ids;
    vector<bool> on_stack;
    stack<ll> st;

    SCCs(ll n0, vector<vector<ll>> &adj0) {
        n = n0, idx = 0, scc_cnt = 0;
        adj = adj0;
        ord = vector<ll>(n, -1);
        low = vector<ll>(n, -1);
        ids = vector<ll>(n, -1);
        on_stack = vector<bool>(n, false);
        FOR (u, n) {
            if (ord[u] == -1) {
                dfs(u);
            }
        }
        adj_scc = vector<vector<ll>>(scc_cnt);
        FOR (u, n) {
            FORE (v, adj[u]) {
                if (ids[u] != ids[v]) {
                    adj_scc[ids[u]].pb(ids[v]);
                }
            }
        }
    }

    void dfs(ll u) {
        ord[u] = low[u] = idx++;
        st.push(u);
        on_stack[u] = true;
        FORE (v, adj[u]) {
            if (ord[v] == -1) {
                dfs(v);
                low[u] = min(low[u], low[v]);
            } elif (on_stack[v]) {
                low[u] = min(low[u], ord[v]);
            }
        }
        if (low[u] == ord[u]) {
            while (true) {
                ll v = st.top();
                st.pop();
                ids[v] = scc_cnt;
                on_stack[v] = false;
                if (u == v) {
                    break;
                }
            }
            scc_cnt++;
        }
    }
};

//--------------------------------------------------

struct SegTree {
    ll n;
    vector<ll> data, lazy;
    SegTree (ll n) : n(n), data(4 * n), lazy(4 * n) {}
    void push(ll i, ll l, ll r) {
        if (lazy[i] == 0) return;
        data[i] += (r - l) * lazy[i];
        if (r - l > 1) {
            lazy[2 * i] += lazy[i];
            lazy[2 * i + 1] += lazy[i];
        }
        lazy[i] = 0;
    }
    void update(ll ul, ll ur, ll val, ll i = 1, ll l = 0, ll r = -1) { // [ul, ur)
        if (r == -1) r = n;
        push(i, l, r);
        if (ur <= l || r <= ul) return;
        if (ul <= l && r <= ur) {
            lazy[i] += val;
            push(i, l, r);
            return;
        }
        ll m = (l + r) / 2;
        update(ul, ur, val, 2 * i, l, m);
        update(ul, ur, val, 2 * i + 1, m, r);
        data[i] = data[2 * i] + data[2 * i + 1];
    }
    ll query(ll ql, ll qr, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) r = n;
        push(i, l, r);
        if (qr <= l || r <= ql) return 0;
        if (ql <= l && r <= qr) return data[i];
        ll m = (l + r) / 2;
        return query(ql, qr, 2 * i, l, m) + query(ql, qr, 2 * i + 1, m, r);
    }
};

//--------------------------------------------------

struct Vertex { // persistent segtree, sum
    Vertex *l, *r;
    ll sum;
    Vertex(ll val) : l(nullptr), r(nullptr), sum(val) {}
    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {
        if (l) sum += l->sum;
        if (r) sum += r->sum;
    }
};

Vertex* build(vector<ll> &a, ll tl, ll tr) { // [tl, tr]
    if (tl == tr) return new Vertex(a[tl]);
    ll tm = (tl + tr) / 2;
    return new Vertex(build(a, tl, tm), build(a, tm + 1, tr));
}

ll get_sum(Vertex* v, ll tl, ll tr, ll l, ll r) { // [tl, tr] = [0, n - 1], [l, r]
    if (l > r) return 0;
    if (l == tl && tr == r) return v->sum;
    ll tm = (tl + tr) / 2;
    return get_sum(v->l, tl, tm, l, min(r, tm))
         + get_sum(v->r, tm + 1, tr, max(l, tm + 1), r);
}

Vertex* update(Vertex* v, ll tl, ll tr, ll pos, ll new_val) { // [tl, tr] = [0, n - 1]
    if (tl == tr) return new Vertex(new_val);
    ll tm = (tl + tr) / 2;
    if (pos <= tm) return new Vertex(update(v->l, tl, tm, pos, new_val), v->r);
    else return new Vertex(v->l, update(v->r, tm + 1, tr, pos, new_val));
}

//--------------------------------------------------

ld shoelace(vector<pair<ld, ld>> &v) {
    ld area = 0;
    FOR (i, sz(v)) {
        area += (v[i].first * v[(i + 1) % sz(v)].second) -
            (v[i].second * v[(i + 1) % sz(v)].first);
    }
    return abs(area) / 2;
}

//--------------------------------------------------

struct SuffixTree {
    str s; // input string for which the suffix tree is being built
    vector<vector<ll>> tree; // array of transitions (state, letter)
    // left... and right boundaries of the substring of s which correspond to incoming edge
    // parent of the node
    // suffix link
    vector<ll> lo, hi, par, link;
    // maximum possible number of nodes in suffix tree
    // number of letters in the alphabet
    ll n, alpha;
    // the node of the current suffix (if we're mid-edge, the lower node of the edge)
    // position in the string which corresponds to the position on the edge (between lo[cur_node] and hi[cur_node], inclusive)
    // the number of nodes
    // the current character in the string
    ll cur_node, cur_pos, cur_size, cur_char;

    SuffixTree(str &s_in, ll alpha = 27) : s(s_in), alpha(alpha) {
        s += '$';
        n = sz(s) * 2 + 2;
        tree = vector<vector<ll>>(n, vector<ll>(alpha, -1));
        lo = vector<ll>(n);
        hi = vector<ll>(n, sz(s) - 1);
        par = vector<ll>(n);
        link = vector<ll>(n);
        cur_size = 2;
        cur_node = 0;
        cur_pos = 0;
        // initialize data for the root of the tree
        link[0] = 1;
        lo[0] = -1;
        hi[0] = -1;
        lo[1] = -1;
        hi[1] = -1;
        tree[1] = vector<ll>(alpha, 0);
        // add the text to the tree, letter by letter
        for (cur_char = 0; cur_char < sz(s); cur_char++) {
            add_char(char_to_index(s[cur_char]));
        }
    }

    ll char_to_index(ch c) {
        if (c == '$') {
            return 26;
        } else {
            return c - 'a';
        }
    }

    // add character c to the tree
    void add_char(ll c) {
        // we'll return here after each transition to the suffix (and will add character again)
        suff:;
        // check whether we're still within the boundaries of the current edge
        if (hi[cur_node] < cur_pos) {
            // if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree
            if (tree[cur_node][c] == -1) {
                tree[cur_node][c] = cur_size;
                lo[cur_size] = cur_char;
                par[cur_size++] = cur_node;
                cur_node = link[cur_node];
                cur_pos = hi[cur_node] + 1;
                goto suff;
            }
            cur_node = tree[cur_node][c];
            cur_pos = lo[cur_node];
        } // otherwise just proceed to the next edge
        if (cur_pos == -1 || c == char_to_index(s[cur_pos])) {
            cur_pos++; // if the letter on the edge equal c, go down that edge
        } else { 
            // otherwise split the edge in two with middle in node cur_size
            lo[cur_size] = lo[cur_node];
            hi[cur_size] = cur_pos - 1;
            par[cur_size] = par[cur_node];
            tree[cur_size][char_to_index(s[cur_pos])] = cur_node;
            // add leaf cur_size+1. It corresponds to transition through c.
            tree[cur_size][c] = cur_size + 1;
            lo[cur_size + 1] = cur_char;
            par[cur_size + 1] = cur_size;
            // update info for the current node - remember to mark cur_size as parent of cur_node
            lo[cur_node] = cur_pos;
            par[cur_node] = cur_size;
            tree[par[cur_size]][char_to_index(s[lo[cur_size]])] = cur_size;
            cur_size += 2;
            // prepare for descent
            // cur_pos will mark where are we in the current suffix
            cur_node = link[par[cur_size - 2]];
            cur_pos = lo[cur_size - 2];
            // while the current suffix is not over, descend
            while (cur_pos <= hi[cur_size - 2]) {
                cur_node = tree[cur_node][char_to_index(s[cur_pos])];
                cur_pos += hi[cur_node] - lo[cur_node] + 1;
            }
            // if we're in a node, add a suffix link to it, otherwise add the link to cur_size
            // (we'll create cur_size on next iteration).
            if (cur_pos == hi[cur_size - 2] + 1) {
                link[cur_size - 2] = cur_node;
            } else {
                link[cur_size - 2] = cur_size;
            } 
            // add cur_pos to the new edge and return to add letter to suffix
            cur_pos = hi[cur_node] - (cur_pos - hi[cur_size - 2]) + 2;
            goto suff;
        }
    }

    void print() {
        FOR (i, cur_size) {
            cout << i << ':' << lo[i] << ' ' << hi[i] << ' ' << par[i] << ' ' << link[i] << " " << '\n';
            FOR (j, alpha) {
                if (tree[i][j] != -1) {
                    if (j == 26) {
                        cout << "$ ";
                    } else {
                        cout << (char)('a' + j) << ' ';
                    }
                    cout << tree[i][j] << '\n';
                }
            }
        }
    }
};

ll gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth, ll v = 0, ll d = 0) {
    depth[v] = d;
    ll rv = 0;
    FOR (i, st.alpha) {
        if (st.tree[v][i] != -1) {
            rv += gen_tree(st, leafs, depth, st.tree[v][i], d + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1);
        }
    }
    if (rv == 0) {
        rv = 1;
    }
    leafs[v] = rv;
    return rv;
}

void gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth) {
    vector<ll> in(st.cur_size);
    queue<ll> depth_q, leaf_q;
    depth_q.push(0);
    while (!depth_q.empty()) {
        ll v = depth_q.front();
        depth_q.pop();
        bool is_leaf = true;
        FOR (i, st.alpha) {
            if (st.tree[v][i] != -1) {
                depth[st.tree[v][i]] = depth[v] + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1;
                depth_q.push(st.tree[v][i]);
                in[v]++;
                is_leaf = false;
            }
        }
        if (is_leaf) {
            leafs[v] = 1;
            leaf_q.push(v);
        }
    }
    while (!leaf_q.empty()) {
        ll v = leaf_q.front();
        leaf_q.pop();
        if (v != 0) {
            leafs[st.par[v]] += leafs[v];
            in[st.par[v]]--;
            if (in[st.par[v]] == 0) {
                leaf_q.push(st.par[v]);
            }
        }
    }
}

bool dfs(ll u, SuffixTree &st, str &s, str &rv, ll &n) {
    ll lo = 0, hi = -1;
    if (u) {
        lo = st.lo[u];
        hi = min(min(st.hi[u], sz(s) - 1), lo + n - 1);
    }
    n -= hi - lo + 1;
    if (n == 0) {
        rv = s.substr(lo, hi - lo + 1);
        return true;
    }
    FOR (i, 26) {
        ll &v = st.tree[u][i];
        if (v != -1 && dfs(v, st, s, rv, n)) {
            rv = s.substr(lo, hi - lo + 1) + rv;
            return true;
        }
    }
    return false;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    str s;
    cin >> s;
    SuffixTree st(s);
    vector<int> leafs(st.cur_size), depth(st.cur_size);
    gen_tree(st, leafs, depth);
    int k;
    cin >> k;

    while (k--) {
        str t;
        cin >> t;

        int i = 0, v = 0;
        if (st.tree[0][st.char_to_index(t[0])] == -1) {
            cout << 0 << '\n';
            continue;
        } else {
            v = st.tree[0][st.char_to_index(t[0])];
        }

        bool ok = true;
        int idx = 0;
        while (i < sz(t)) {
            int j = st.lo[v];
            while (j <= st.hi[v] && i < sz(t) && t[i] == s[j]) {
                i++;
                j++;
            }
            if (i == sz(t)) {
                idx = j - sz(t) + 1;
                break;
            }
            if (j > st.hi[v]) {
                if (st.tree[v][st.char_to_index(t[i])] == -1) {
                    ok = false;
                    break;
                } else {
                    v = st.tree[v][st.char_to_index(t[i])];
                }
            } else {
                ok = false;
                break;
            }
        }
    }

    return 0;
}

//--------------------------------------------------

void make_clockwise(vector<pair<ld, ld>> &points) {
    pair<ld, ld> center = mp(0, 0);
    FORE (p, points) {
        center.first += p.first;
        center.second += p.second;
    }
    center.first /= sz(points);
    center.second /= sz(points);
    sort(all(points), [center](pair<ld, ld> &p1, pair<ld, ld> &p2) {
        return atan2(p1.second - center.second, p1.first - center.first) <
               atan2(p2.second - center.second, p2.first - center.first);
    });
}

bool in_triangle(pair<ld, ld> &point, vector<pair<ld, ld>> &triangle) {
    vector<ld> d(3);
    FOR (i, 3) {
        auto &p1 = triangle[i];
        auto &p2 = triangle[(i + 1) % 3];
        d[i] = (p2.first - p1.first) * (point.second - p1.second) -
            (p2.second - p1.second) * (point.first - p1.first);
    }
    return (d[0] >= 0 && d[1] >= 0 && d[2] >= 0) || (d[0] <= 0 && d[1] <= 0 && d[2] <= 0);
}

//--------------------------------------------------

constexpr ll ALPHA = 26;

struct Trie {
    ch c;
    bool ending = false;
    vector<Trie*> children = vector<Trie*>(ALPHA, nullptr);

    Trie(ch c_) : c(c_) {}

    void insert(ll i, str &s) {
        if (i == sz(s)) {
            ending = true;
            return;
        }
        ll si = s[i] - 'a';
        if (children[si] == nullptr) {
            children[si] = new Trie(s[i]);
        }
        children[si]->insert(i + 1, s);
    }
};