#include <bits/stdc++.h>

using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef complex<long double> cd;
typedef long double ld;
typedef char ch;
typedef string str;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#include <bits/extc++.h>
using namespace __gnu_pbds;

using indexed_set = tree<
    pair<ll, ll>,
    null_type,
    less<pair<ll, ll>>,
    rb_tree_tag,
    tree_order_statistics_node_update
>;

#pragma GCC target("popcnt,lzcnt")

#define pb push_back
#define elif else if
#define sz(C) (ll) C.size()
#define all(C) C.begin(), C.end()
#define flip(C) reverse(all(C))
#define ssort(C) sort(all(C))
#define rsort(C) sort(all(C), greater<>())

#define FOR(x, e) for(ll x = 0; x < (ll) e; x++)
#define FORR(x, e) for(ll x = (ll) e - 1; x >= 0; x--)
#define FOB(x, b, e) for(auto x = b; x < e; x++)
#define FORE(x, C) for(auto &x : C)

// Run -> Add configuration... -> in launch.json:
// "program": "${fileDirname}/${fileBasenameNoExtension}",
// "preLaunchTask": "C/C++: g++ build active file",

//--------------------------------------------------

// clockwise angle from (x1, y1) to (x0, y0) to (x2, y2)
ld angle(ld x1, ld y1, ld x0, ld y0, ld x2, ld y2) {
    ld dot = (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0),
        det = (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0),
        rv = atan2(det, dot);
    if (rv < 0) {
        rv += 2 * M_PI;
    }
    return rv;
}

//--------------------------------------------------

void bellman_ford(ll v, vector<tuple<ll, ll, ll>> &edges, vector<ll> &dist) {
    ll n = sz(dist);
    FOR (i, n) {
        dist[i] = INF;
    }
    dist[v] = 0;
    FOR (i, n - 1) {
        for (auto [a, b, w] : edges) {
            if (dist[a] != INF && dist[a] + w < dist[b]) {
                dist[b] = dist[a] + w;
            }
        }
    }
}

void dijkstra(ll v0, vector<vector<pair<ll, ll>>> &adj, vector<ll> &dist) {
    std::priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<>> pq;
    pq.push({0, v0});
    while (!pq.empty()) {
        ll cur_d, u;
        tie(cur_d, u) = pq.top();
        pq.pop();
        if (cur_d > dist[u]) {
            continue;
        }
        FORE (elem, adj[u]) {
            ll v, w;
            tie(v, w) = elem;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }
}

void floyd_warshall(vector<vector<ll>> &dist) {
    ll n = sz(dist);
    FOR (k, n) {
        FOR (i, n) {
            FOR (j, n) {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
}

//--------------------------------------------------

ll bin_search_find_last(vector<ll> &a) {
        ll lo = 0, hi = sz(a) - 1;
        while (lo < hi) {
            ll mid = (lo + hi + 1) / 2;
            if (valid(mid)) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
}

ll bin_search_find_first(vector<ll> &a) {
    ll lo = 0, hi = sz(a) - 1;
    while (lo < hi) {
        ll mid = (lo + hi) / 2;
        if (valid(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
}

//--------------------------------------------------

struct BIT {
    vector<ll> tree;
    ll n;
    BIT(ll n) : n(n) {
        tree.resize(n + 1);
    }
    void update(ll idx, ll val) {
        idx++;
        while (idx <= n) {
            tree[idx] += val;
            idx += idx & (-idx);
        }
    }
    ll query(ll idx) {
        idx++;
        ll sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= idx & (-idx);
        }
        return sum;
    }
    ll query(ll l, ll r) {
        return query(r) - query(l - 1);
    }
};

struct BIT2d {
    vector<BIT> tree;
    ll n, m;
    BIT2d(ll n, ll m) : n(n), m(m) {
        tree.resize(n + 1, BIT(m));
    }
    void update(ll x, ll y, ll val) {
        x++;
        while (x <= n) {
            tree[x].update(y, val);
            x += x & (-x);
        }
    }
    ll query(ll x, ll y) {
        x++;
        ll sum = 0;
        while (x > 0) {
            sum += tree[x].query(y);
            x -= x & (-x);
        }
        return sum;
    }
    ll query(ll x1, ll y1, ll x2, ll y2) {
        return query(x2, y2) - query(x1 - 1, y2) - query(x2, y1 - 1) + query(x1 - 1, y1 - 1);
    }
};

//--------------------------------------------------

pair<ld, ld> get_com(vector<pair<ld, ld>> &poly) {
    ld x = 0, y = 0;
    ld area = 0;
    FOR (i, sz(poly)) {
        ll j = (i + 1) % sz(poly);
        ld a = poly[i].first * poly[j].second - poly[j].first * poly[i].second;
        area += a;
        x += (poly[i].first + poly[j].first) * a;
        y += (poly[i].second + poly[j].second) * a;
    }
    area /= 2;
    x /= 6 * area;
    y /= 6 * area;
    return {x, y};
}

//--------------------------------------------------

struct Point {
    ld x, y;
    Point operator+(Point o) {
        return {x + o.x, y + o.y};
    }
    Point operator-(Point o) {
        return {x - o.x, y - o.y};
    }
    Point operator*(ld k) {
        return {x * k, y * k};
    }
    Point operator/(ld k) {
        return {x / k, y / k};
    }
    ld abs2() {
        return x * x + y * y;
    }
    ld abs_() {
        return sqrt(abs2());
    }
    bool operator==(Point o) {
        return abs(x - o.x) < EPS && abs(y - o.y) < EPS;
    }
    bool operator!=(Point o) {
        return abs(x - o.x) > EPS || abs(y - o.y) > EPS;
    }
};

struct Circle {
    Point c;
    ld r;
    ll id;
    Circle(Point c, ld r, ll id) : c(c), r(r), id(id) {}
    Circle() {}
    bool has(Point &p) {
        return (p - c).abs_() <= r + EPS;
    }
    vector<Point> operator&(Circle &o) {
        if ((c - o.c).abs_() > r + o.r + EPS || (c - o.c).abs_() < abs(r - o.r) - EPS) {
            return {};
        }
        if ((c - o.c).abs_() < EPS && abs(r - o.r) < EPS) {
            return {{c.x + r, c.y}};
        }
        Point sum = o.c + c, diff = o.c - c, perp = {diff.y, -diff.x};
        ld csu = 0.5,
            cdi = (r * r - o.r * o.r) / (2 * diff.abs2()),
            cpe = 0.5 * sqrt(max((ld) 0, 2 * (r * r + o.r * o.r) / (diff.abs2())
                - (r * r - o.r * o.r) * (r * r - o.r * o.r) / (diff.abs2() * diff.abs2()) - 1));
        vector<Point> rv = {sum * csu + diff * cdi + perp * cpe, sum * csu + diff * cdi - perp * cpe};
        return rv;
    }
};

//--------------------------------------------------

vector<pair<ll, ll>> convex_hull(vector<pair<ll, ll>> pts) {
    if (sz(pts) <= 1) return pts;
    sort(all(pts));
    vector<pair<ll, ll>> h(sz(pts) + 1);
    int s = 0, t = 0;
    FOR (it, 2) {
        FOR (i, sz(pts)) {
            auto p = pts[i];
            while (t >= s + 2 && (h[t - 2].first - h[t - 1].first) * (p.second - h[t - 1].second) - (h[t - 2].second - h[t - 1].second) * (p.first - h[t - 1].first) <= 0) t--;
            h[t++] = p;
        }
        s = t--;
        reverse(all(pts));
    }
    return {h.begin(), h.begin() + t - (t == 2 && h[0] == h[1])};
}

//--------------------------------------------------

void customsort() {
    vector<ll> x;
    sort(x.begin(), x.end(),
        &[] (const ll &a, const ll &b) -> bool
        { return a < b; });
    // equivalent to regular sort
}

//--------------------------------------------------

struct Edge {
    ll s, t, cap = 0, cost = 0, flow = 0;
};

struct Dinic {
    ll n;
    vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> lvl, ptr;
    queue<ll> q;

    Dinic(ll n, vector<Edge> &edges0) :
        n(n), adj(n), lvl(n), ptr(n) {
        ll i = 0;
        FORE (e, edges0) {
            edges.pb(e);
            edges.pb({e.t, e.s});
            adj[e.s].pb(i++);
            adj[e.t].pb(i++);
        }
    }

    bool bfs(ll s, ll t) {
        lvl.assign(n, -1);
        lvl[s] = 0;
        q.push(s);
        while (!q.empty()) {
            ll v = q.front();
            q.pop();
            FORE (e, adj[v]) {
                ll u = edges[e].t;
                if (lvl[u] != -1 || edges[e].cap <= edges[e].flow) continue;
                lvl[u] = lvl[v] + 1;
                q.push(u);
            }
        }
        return lvl[t] != -1;
    }

    ll dfs(ll v, ll t, ll f) {
        if (v == t || f == 0) return f;
        for (ll &cid = ptr[v]; cid < sz(adj[v]); cid++) {
            ll e = adj[v][cid];
            ll u = edges[e].t;
            if (lvl[v] + 1 != lvl[u]) continue;
            ll pushed = dfs(u, t, min(f, edges[e].cap - edges[e].flow));
            if (pushed) {
                edges[e].flow += pushed;
                edges[e ^ 1].flow -= pushed;
                return pushed;
            }
        }
        return 0;
    }

    ll max_flow(ll s, ll t) {
        ll flow = 0;
        while (bfs(s, t)) {
            ptr.assign(n, 0);
            while (ll pushed = dfs(s, t, INF)) flow += pushed;
        }
        return flow;
    }

    vector<pair<ll, ll>> min_cut(ll s) {
        bfs(s, n - 1);
        vector<pair<ll, ll>> cut;
        FORE (e,edges) {
            if (lvl[e.s] != -1 && lvl[e.t] == -1 && e.cap > 0) cut.pb({e.s, e.t});
        }
        return cut;
    }

    void undo_flow(vector<ll> path, ll f) {
        FOR (i, sz(path) - 1) {
            FORE (e, adj[path[i]]) {
                if (edges[e].t == path[i + 1]) {
                    edges[e].flow -= f;
                    edges[e ^ 1].flow += f;
                    assert(edges[e].flow <= edges[e].cap);
                    assert(edges[e ^ 1].flow <= edges[e ^ 1].cap);
                    break;
                }
            }
        }
    }
};

struct MinCostMaxFlow {
    ll n, m;
    vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> dist, pi, vis;
    vector<pair<ll, ll>> par;

    MinCostMaxFlow(ll n, vector<Edge> &edges0) :
        n(n), m(sz(edges0)), adj(n),
        vis(n), dist(n), pi(n), par(n) {
        ll i = 0;
        FORE (e, edges0) {
            edges.pb(e);
            edges.pb({e.t, e.s});
            adj[e.s].pb(i++);
            adj[e.t].pb(i++);
        }
    }

    void path(ll s) {
        vis.assign(n, false);
        dist.assign(n, INF);
        dist[s] = 0;
        ll di;

        __gnu_pbds::priority_queue<pair<ll, ll>, greater<>> pq;
        vector<decltype(pq)::point_iterator> its(n);
        pq.push({0, s});

        auto relax = [&](ll t, ll e, ll cap, ll cost, ll dir) {
            ll val = di - pi[t] + cost;
            if (cap && val < dist[t]) {
                dist[t] = val;
                par[t] = {e, dir};
                if (its[t] == pq.end()) {
                    its[t] = pq.push({val, t});
                } else {
                    pq.modify(its[t], {val, t});
                }
            }
        };

        while (!pq.empty()) {
            s = pq.top().second;
            pq.pop();
            vis[s] = 1;
            di = dist[s] + pi[s];
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) {
                    relax(t, e, edges[e].cap - edges[e].flow, edges[e].cost, 1);
                }
            }
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) {
                    relax(t, e, edges[e ^ 1].flow, -edges[e ^ 1].cost, 0);
                }
            }
        }

        FOR (i, n) {
            pi[i] = min(pi[i] + dist[i], INF);
        }
    }

    pair<ll, ll> max_flow(ll s, ll t) {
        ll flow = 0, cost = 0;
        while (path(s), vis[t]) {
            ll f = INF;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                f = min(f, r ? edges[p].cap - edges[p].flow : edges[p ^ 1].flow);
            }
            flow += f;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                if (r) edges[p].flow += f;
                else edges[p ^ 1].flow -= f;
            }
        }
        FORE (e, edges) {
            cost += e.flow * e.cost;
        }
        return {flow, cost};
    }

    void set_pi(ll s) { // for negative costs
        pi.assign(n, INF);
        pi[s] = 0;
        ll it = n, ch = 1, v;
        while (ch-- && it--) {
            FOR (i, n) {
                if (pi[i] == INF) continue;
                FORE (e, adj[i]) {
                    if (edges[e].cap && (v = pi[i] + edges[e].cost) < pi[edges[e].t]) {
                        pi[edges[e].t] = v;
                        ch = 1;
                    }
                }
            }
        }
        assert(it >= 0);
    }
};

//--------------------------------------------------

struct DSU {
    ll cnt;
    vector<ll> e;
    DSU(ll n) { e = vector<ll>(n, -1); cnt = n; }
    void reset() { e = vector<ll>(sz(e), -1); cnt = sz(e); }
    ll get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
    bool same_set(ll a, ll b) { return get(a) == get(b); }
    ll size(ll x) { return -e[get(x)]; }
    bool unite(ll x, ll y) {
        x = get(x), y = get(y);
        if (x == y) return false;
        if (e[x] > e[y]) swap(x, y);
        e[x] += e[y]; e[y] = x;
        cnt--;
        return true;
    }
};

//--------------------------------------------------

constexpr ll MOD = 1e9 + 7;

struct Binom {
    ll n;
    vector<ll> fac, ifac;
    vector<vector<ll>> stirling;
    Binom(ll n) : n(n) {
        fac.resize(n + 1);
        ifac.resize(n + 1);
        stirling.resize(n + 1, vector<ll>(n + 1));
        fac[0] = 1;
        FOB (i, 1, n + 1) fac[i] = fac[i - 1] * i % MOD;
        ifac[n] = pow(fac[n], MOD - 2);
        FORR (i, n) ifac[i] = ifac[i + 1] * (i + 1) % MOD;
        stirling[0][0] = 1;
        FOB (i, 1, n + 1) {
            FOB (j, 1, i + 1) {
                stirling[i][j] = (stirling[i - 1][j - 1] + (i - 1) * stirling[i - 1][j]) % MOD;
            }
        }
    }
    ll pow(ll a, ll b) {
        ll rv = 1;
        while (b) {
            if (b & 1) rv = rv * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return rv;
    }
    ll choose(ll n, ll k) {
        if (k < 0 || k > n) return 0;
        else return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;
    }
    ll stirling1(ll n, ll k) {
        return abs(stirling[n][k]);
    }
};

//--------------------------------------------------

// ll n = sz(s), n2 = 1LL << (64 - __builtin_clz(n));
// vector<cd> a(n2), b(n2);
// ...init a, b...
// fft(a, false);
// fft(b, false);
// FOR (i, n) a[i] *= b[i];
// fft(a, true);

void fft(vector<cd> &a, bool inv) {
    int n = sz(a);
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        ld ang = 2 * M_PI / len * (inv ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i + j], v = a[i + j + len / 2] * w;
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }
    if (inv) FORE (x, a) x /= n;
}

//--------------------------------------------------

bool game(auto state, bool alice) {
    if (mem.find(state) != mem.end()) {
        return mem[state];
    }
    FORE (move, all_moves) {
        if (valid(move)) {
            change_state();
            if (!game(state, !alice)) {
                restore_state();
                mem[state] = true;
                return true;
            }
            restore_state();
        }
    }
    mem[state] = false;
    return false;
}

//--------------------------------------------------

ll gauss_jordan(vector<vector<ld>> &A, vector<ld> &b, vector<ld> &x) {
    ll n = A.size(), m = A[0].size();
    vector<vector<ld>> a(n, vector<ld>(m + 1));
    FOR(i, n) {
        FOR(j, m) {
            a[i][j] = A[i][j];
        }
        a[i][m] = b[i];
    }
    vector<ll> where(m, -1);
    for (ll col = 0, row = 0; col < m && row < n; col++) {
        ll sel = row;
        FOB (i, row, n) {
            if (abs(a[i][col]) > abs(a[sel][col])) {
                sel = i;
            }
        }
        if (abs(a[sel][col]) < EPS) {
            continue;
        }
        FOB (i, col, m + 1) {
            swap(a[sel][i], a[row][i]);
        }
        where[col] = row;
        FOR (i, n) {
            if (i != row) {
                ld c = a[i][col] / a[row][col];
                FOB (j, col, m + 1) {
                    a[i][j] -= a[row][j] * c;
                }
            }
        }
        row++;
    }
    x.assign(m, 0);
    FOR (i, m) {
        if (where[i] != -1) {
            x[i] = a[where[i]][m] / a[where[i]][i];
        }
    }
    FOR (i, n) {
        ld sum = 0;
        FOR (j, m) {
            sum += a[i][j] * x[j];
        }
        if (abs(sum - a[i][m]) > EPS) { // may need to change for modulo
            return 0;
        }
    }
    FOR (i, m) {
        if (where[i] == -1) {
            return INF;
        }
    }
    return 1;
}

int gauss_jordan_binary(
    vector<bitset<MAXN>> A,
    bitset<MAXN> &b,
    bitset<MAXN> &x,
    int n,
    int m
) {
    FOR (i, n) {
        A[i][m] = b[i];
    }
    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; col++) {
        FOB (i, row, n) {
            if (A[i][col] != 0) {
                swap(A[i], A[row]);
                break;
            }
        }
        if (A[row][col] == 0) {
            continue;
        }
        where[col] = row;
        FOR (i, n) {
            if (i != row && A[i][col] != 0) {
                A[i] ^= A[row];
            }
        }
        row++;
    }
    x = bitset<MAXN>(0);
    FOR (i, m) {
        if (where[i] != -1) {
            x[i] = A[where[i]][m] / A[where[i]][i];
        }
    }
    FOR (i, n) {
        int sum = 0;
        FOR (j, m) {
            sum += A[i][j] * x[j];
        }
        if (sum != A[i][m]) {
            return 0;
        }
    }
    FOR (i, m) {
        if (where[i] == -1) {
            return INF;
        }
    }
    return 1;
}

//--------------------------------------------------

ll gcd(ll a, ll b) {
    if (a == 0) return b;
    return gcd(b % a, a);
}

// a * x + b * y = gcd(a, b)

pair<ll, ll> bezout(ll a, ll b) {
    if (a == 0) return {0, 1};
    auto [x, y] = bezout(b % a, a);
    return {y - (b / a) * x, x};
}

// x % m == a, x % n == b
// x % lcm(m, n) = -(a * v * n + b * u * m) / gcd(m, n)

ll crt(ll m, ll n, ll a, ll b) {
    ll g = gcd(m, n);
    if (a % g != b % g) return -1;
    ll lcm = m * n / g;
    auto [u, v] = bezout(m / g, n / g);
    ll k = (b - a) / g;
    ll x = (a + m * k * u) % lcm;
    if (x < 0) x += lcm;
    return x;
}

//--------------------------------------------------

vector<ll> hungarian(vector<vector<ll>> &costs) {
    ll J = sz(costs), W = sz(costs[0]); // J <= W
    vector<ll> job(W + 1, -1), ys(J), yt(W + 1), rv;
    FOR (j_cur, J) {
        ll w_cur = W;
        job[w_cur] = j_cur;
        vector<ll> min_to(W + 1, INF), prev(W + 1, -1);
        vector<bool> in_Z(W + 1);
        while (job[w_cur] != -1) {
            in_Z[w_cur] = true;
            ll j = job[w_cur], del = INF, w_nxt;
            FOR (w, W) {
                if (!in_Z[w]) {
                    if (min_to[w] > costs[j][w] - ys[j] - yt[w]) {
                        min_to[w] = costs[j][w] - ys[j] - yt[w];
                        prev[w] = w_cur;
                    }
                    if (del > min_to[w]) {
                        del = min_to[w];
                        w_nxt = w;
                    }
                }
            }
            FOR (w, W + 1) {
                if (in_Z[w]) ys[job[w]] += del, yt[w] -= del;
                else min_to[w] -= del;
            }
            w_cur = w_nxt;
        }
        for (ll w; w_cur != W; w_cur = w) job[w_cur] = job[w = prev[w_cur]];
        rv.pb(-yt[W]);
    }
    return rv;
}

//--------------------------------------------------

struct LCA_Tree {
    vector<vector<ll>> parent, adj;
    vector<ll> pre, post, depth;
    ll n, timer;
    LCA_Tree(ll &n0, vector<vector<ll>> &adj0) {
        n = n0;
        timer = 0;
        pre = vector<ll>(n), post = pre, depth = pre;
        parent = vector<vector<ll>>(n, vector<ll>(30));
        adj = adj0;
        dfs(0, 0, 0);
        gen();
    }
    void dfs(ll node, ll par, ll d) {
        pre[node] = timer++;
        depth[node] = d;
        parent[node][0] = par;
        FORE (child, adj[node]) {
            if (child != par) {
                dfs(child, node, d + 1);
            }
        }
        post[node] = timer++;
    }
    void gen() {
        FOR (i, 29) {
            FOR (j, n) {
                parent[j][i + 1] = parent[parent[j][i]][i];
            }
        }
    }
    bool is_anc(ll u, ll v) {
        return pre[u] <= pre[v] && post[u] >= post[v];
    }
    ll lca(ll u, ll v) {
        if (is_anc(u, v)) return u;
        if (is_anc(v, u)) return v;
        FORR (i, 30) {
            if (!is_anc(parent[u][i], v)) {
                u = parent[u][i];
            }
        }
        return parent[u][0];
    }
    ll dist(ll u, ll v) {
        return depth[u] + depth[v] - 2 * depth[lca(u, v)];
    }
    bool disjoint(vector<pair<ll, ll>> paths) {
        vector<pair<ll, ll>> p;
        FORE (path, paths) {
            ll u, v;
            tie(u, v) = path;
            ll w = lca(u, v);
            p.pb({w, u});
            p.pb({w, v});
        }
        FOR (i, sz(p)) {
            FOR (j, i - i % 2) {
                if (!(lca(p[i].second, p[j].first) != p[j].first ||
                    lca(p[j].second, p[i].first) != p[i].first))
                {
                    return false;
                }
            }
        }
        return true;
    }
};

//--------------------------------------------------

pair<ll, ll> manacher(str &s) {
    str t = "$#";
    FORE (c, s) {
        t += c;
        t += '#';
    }
    ll n = sz(t);
    ll center = 0, max_rad = -1, rad;
    vector<ll> p(n);
    FOR (i, n) {
        if (i <= max_rad) {
            rad = min(p[2 * center - i], max_rad - i);
        } else {
            rad = 0;
        }
        while (i - rad - 1 >= 0 && i + rad + 1 < n && t[i - rad - 1] == t[i + rad + 1]) {
            rad++;
        }
        p[i] = rad;
        if (i + rad > max_rad) {
            center = i;
            max_rad = i + rad;
        }
    }
    ll len = 0, idx = 0;
    FOR (i, n) {
        if (p[i] > len) {
            len = p[i];
            idx = i;
        }
    }
    return {len, (idx - len) / 2};
}

//--------------------------------------------------

struct Matrix { // mat[i] is row i
    vector<vector<ll>> mat;
    ll n, m;
    Matrix(ll n, ll m) : n(n), m(m) {
        mat.resize(n, vector<ll>(m));
    }
    Matrix operator*(const Matrix &other) const {
        Matrix rv(n, other.m);
        FOR(i, n) {
            FOR(j, other.m) {
                FOR(k, m) {
                    rv.mat[i][j] += mat[i][k] * other.mat[k][j];
                    rv.mat[i][j] %= MOD;
                }
            }
        }
        return rv;
    }
    Matrix operator^(ll p) const {
        Matrix rv(n, n);
        FOR(i, n) {
            rv.mat[i][i] = 1;
        }
        Matrix a = *this;
        while (p) {
            if (p & 1) {
                rv = rv * a;
            }
            a = a * a;
            p >>= 1;
        }
        return rv;
    }
    ld det() const {
        Matrix a = *this;
        ld rv = 1;
        FOR(i, n) {
            ll p = i;
            FOB(j, i + 1, n) {
                if (abs(a.mat[j][i]) > abs(a.mat[p][i])) {
                    p = j;
                }
            }
            if (p != i) {
                swap(a.mat[i], a.mat[p]);
                rv *= -1;
            }
            if (abs(a.mat[i][i]) < 1e-9) {
                return 0;
            }
            rv *= a.mat[i][i];
            FOB(j, i + 1, n) {
                ld c = a.mat[j][i] / a.mat[i][i];
                FOB(k, i, n) {
                    a.mat[j][k] -= c * a.mat[i][k];
                }
            }
        }
        return rv;
    }
    // min dist
    Matrix operator*(const Matrix &other) const {
        Matrix rv(n, other.m);
        rv.mat.assign(n, vector<ll>(other.m, INF));
        FOR(i, n) {
            FOR(j, other.m) {
                FOR(k, m) {
                    rv.mat[i][j] = min(rv.mat[i][j], mat[i][k] + other.mat[k][j]);
                }
            }
        }
        return rv;
    }

    Matrix operator^(ll p) const {
        Matrix rv(n, n);
        rv.mat.assign(n, vector<ll>(n, INF));
        FOR (i, n) {
            rv.mat[i][i] = 0;
        }
        Matrix a = *this;
        while (p) {
            if (p & 1) {
                rv = rv * a;
            }
            a = a * a;
            p >>= 1;
        }
        return rv;
    }
};

//--------------------------------------------------

ll pow(ll x, ll p) {
    ll rv = 1;
    while(p) {
        if(p & 1) rv *= x;
        x *= x;
        p >>= 1;
    }
    return rv;
}

//--------------------------------------------------

struct SCCs {
    ll n, idx, scc_cnt;
    vector<vector<ll>> adj, adj_scc;
    vector<ll> ord, low, ids;
    vector<bool> on_stack;
    stack<ll> st;

    SCCs(ll n0, vector<vector<ll>> &adj0) {
        n = n0, idx = 0, scc_cnt = 0;
        adj = adj0;
        ord = vector<ll>(n, -1);
        low = vector<ll>(n, -1);
        ids = vector<ll>(n, -1);
        on_stack = vector<bool>(n, false);
        FOR (u, n) {
            if (ord[u] == -1) {
                dfs(u);
            }
        }
        adj_scc = vector<vector<ll>>(scc_cnt);
        FOR (u, n) {
            FORE (v, adj[u]) {
                if (ids[u] != ids[v]) {
                    adj_scc[ids[u]].pb(ids[v]);
                }
            }
        }
    }

    void dfs(ll u) {
        ord[u] = low[u] = idx++;
        st.push(u);
        on_stack[u] = true;
        FORE (v, adj[u]) {
            if (ord[v] == -1) {
                dfs(v);
                low[u] = min(low[u], low[v]);
            } elif (on_stack[v]) {
                low[u] = min(low[u], ord[v]);
            }
        }
        if (low[u] == ord[u]) {
            while (true) {
                ll v = st.top();
                st.pop();
                ids[v] = scc_cnt;
                on_stack[v] = false;
                if (u == v) {
                    break;
                }
            }
            scc_cnt++;
        }
    }
};

//--------------------------------------------------

struct SegTree {
    ll n;
    vector<ll> data, lazy;
    SegTree (ll n) : n(n), data(4 * n), lazy(4 * n) {}
    void push(ll i, ll l, ll r) {
        if (lazy[i] == 0) return;
        data[i] += (r - l) * lazy[i];
        if (r - l > 1) {
            lazy[2 * i] += lazy[i];
            lazy[2 * i + 1] += lazy[i];
        }
        lazy[i] = 0;
    }
    void update(ll ul, ll ur, ll val, ll i = 1, ll l = 0, ll r = -1) { // [ul, ur)
        if (r == -1) r = n;
        push(i, l, r);
        if (ur <= l || r <= ul) return;
        if (ul <= l && r <= ur) {
            lazy[i] += val;
            push(i, l, r);
            return;
        }
        ll m = (l + r) / 2;
        update(ul, ur, val, 2 * i, l, m);
        update(ul, ur, val, 2 * i + 1, m, r);
        data[i] = data[2 * i] + data[2 * i + 1];
    }
    ll query(ll ql, ll qr, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) r = n;
        push(i, l, r);
        if (qr <= l || r <= ql) return 0;
        if (ql <= l && r <= qr) return data[i];
        ll m = (l + r) / 2;
        return query(ql, qr, 2 * i, l, m) + query(ql, qr, 2 * i + 1, m, r);
    }
    void print(ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) r = n;
        cout << "[" << l << ", " << r << "): " << data[i] << " " << lazy[i] << '\n';
        if (r - l > 1) {
            ll m = (l + r) / 2;
            print(2 * i, l, m);
            print(2 * i + 1, m, r);
        }
    }
};

//--------------------------------------------------

struct Vertex { // persistent segtree, sum
    Vertex *l, *r;
    ll sum;
    Vertex(ll val) : l(nullptr), r(nullptr), sum(val) {}
    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {
        if (l) sum += l->sum;
        if (r) sum += r->sum;
    }
};

Vertex* build(vector<ll> &a, ll tl, ll tr) { // [tl, tr]
    if (tl == tr) return new Vertex(a[tl]);
    ll tm = (tl + tr) / 2;
    return new Vertex(build(a, tl, tm), build(a, tm + 1, tr));
}

ll get_sum(Vertex* v, ll tl, ll tr, ll l, ll r) { // [tl, tr] = [0, n - 1], [l, r]
    if (l > r) return 0;
    if (l == tl && tr == r) return v->sum;
    ll tm = (tl + tr) / 2;
    return get_sum(v->l, tl, tm, l, min(r, tm))
         + get_sum(v->r, tm + 1, tr, max(l, tm + 1), r);
}

Vertex* update(Vertex* v, ll tl, ll tr, ll pos, ll new_val) { // [tl, tr] = [0, n - 1]
    if (tl == tr) return new Vertex(new_val);
    ll tm = (tl + tr) / 2;
    if (pos <= tm) return new Vertex(update(v->l, tl, tm, pos, new_val), v->r);
    else return new Vertex(v->l, update(v->r, tm + 1, tr, pos, new_val));
}

//--------------------------------------------------

ld shoelace(vector<pair<ld, ld>> &v) {
    ld area = 0;
    FOR (i, sz(v)) {
        area += (v[i].first * v[(i + 1) % sz(v)].second) -
            (v[i].second * v[(i + 1) % sz(v)].first);
    }
    return abs(area) / 2;
}

//--------------------------------------------------

struct Simplex {
    ll m, n;
    vector<ll> N, B;
    vector<vector<ld>> D;

    // Ax <= b, max c.x with x >= 0
    Simplex(vector<vector<ld>> &A, vector<ld> &b, vector<ld> &c) :
        m(sz(b)), n(sz(c)), N(n + 1), B(m), D(m + 2, vector<ld>(n + 2)) {
        FOR (i, m) FOR (j, n) D[i][j] = A[i][j];
        FOR (i, m) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; }
        FOR (j, n) { N[j] = j; D[m][j] = -c[j]; }
        N[n] = -1; D[m + 1][n] = 1;
    }

    void pivot(ll r, ll s) {
        ld inv = 1 / D[r][s];
        FOR (i, m + 2) if (i != r) FOR (j, n + 2) if (j != s)
            D[i][j] -= D[r][j] * D[i][s] * inv;
        FOR (j, n + 2) if (j != s) D[r][j] *= inv;
        FOR (i, m + 2) if (i != r) D[i][s] *= -inv;
        D[r][s] = inv;
        swap(B[r], N[s]);
    }

    bool simplex(ll phase) {
        ll x = m + phase - 1;
        for (;;) {
            ll s = -1;
            FOR (j, n + 1) if (N[j] != -phase) {
                if (s == -1 || make_pair(D[x][j], N[j]) <
                    make_pair(D[x][s], N[s])) s = j;
            }
            if (D[x][s] >= -EPS) return true;
            ll r = -1;
            FOR (i, m) {
                if (D[i][s] <= EPS) continue;
                if (r == -1 || make_pair(D[i][n + 1] / D[i][s], B[i]) <
                    make_pair(D[r][n + 1] / D[r][s], B[r])) r = i;
            }
            if (r == -1) return false;
            pivot(r, s);
        }
    }

    ll solve(vector<ld> &x) {
        ll r = 0;
        FOB (i, 1, m) if (D[i][n + 1] < D[r][n + 1]) r = i;
        if (D[r][n + 1] < -EPS) {
            pivot(r, n);
            if (!simplex(2) || D[m + 1][n + 1] < -EPS) return -INF;
            FOR (i, m) if (B[i] == -1) {
                ll s = 0;
                FOB (j, 1, n + 1) if (D[i][j] < D[i][s]) s = j;
                pivot(i, s);
            }
        }
        bool ok = simplex(1); x = vector<ld>(n);
        FOR (i, m) if (B[i] < n) x[B[i]] = D[i][n + 1];
        return ok ? D[m][n + 1] : INF;
    }
};

//--------------------------------------------------

struct SuffixArray {
    str s;
    ll n, alpha = 256;
    vector<ll> sorted_shifts;

    SuffixArray(str s) : s(s), n(sz(s)) {
        s += '$', n++; // $ is important
        sorted_shifts = sort_cyclic_shifts();
    }

    vector<ll> sort_cyclic_shifts() {
        vector<ll> p(n), c(n), cnt(max(n, alpha), 0);
        FOR (i, n) cnt[s[i] - 'a']++;
        FOB (i, 1, alpha) cnt[i] += cnt[i - 1];
        FOR (i, n) p[--cnt[s[i] - 'a']] = i;
        c[p[0]] = 0;
        ll classes = 1;
        FOB (i, 1, n) {
            if (s[p[i]] != s[p[i - 1]]) classes++;
            c[p[i]] = classes - 1;
        }
        vector<ll> pn(n), cn(n);
        for (ll h = 0; (1 << h) < n; h++) {
            FOR (i, n) {
                pn[i] = p[i] - (1 << h);
                if (pn[i] < 0) pn[i] += n;
            }
            fill(cnt.begin(), cnt.begin() + classes, 0);
            FOR (i, n) cnt[c[pn[i]]]++;
            FOB (i, 1, classes) cnt[i] += cnt[i - 1];
            FORR (i, n) p[--cnt[c[pn[i]]]] = pn[i];
            cn[p[0]] = 0;
            classes = 1;
            FOB (i, 1, n) {
                pair<ll, ll> cur = {c[p[i]], c[(p[i] + (1 << h)) % n]};
                pair<ll, ll> prev = {c[p[i - 1]], c[(p[i - 1] + (1 << h)) % n]};
                if (cur != prev) classes++;
                cn[p[i]] = classes - 1;
            }
            c.swap(cn);
        }
        p.erase(p.begin()); // remove $
        return p;
    }
};

//--------------------------------------------------

struct SuffixTree {
    str s; // input string for which the suffix tree is being built
    vector<vector<ll>> tree; // array of transitions (state, letter)
    // left... and right boundaries of the substring of s which correspond to incoming edge
    // parent of the node
    // suffix link
    vector<ll> lo, hi, par, link;
    // maximum possible number of nodes in suffix tree
    // number of letters in the alphabet
    ll n, alpha;
    // the node of the current suffix (if we're mid-edge, the lower node of the edge)
    // position in the string which corresponds to the position on the edge (between lo[cur_node] and hi[cur_node], inclusive)
    // the number of nodes
    // the current character in the string
    ll cur_node, cur_pos, cur_sz, cur_ch;
 
    SuffixTree(str &s_in, ll alpha = 27) : s(s_in), alpha(alpha) {
        s += '$';
        n = sz(s) * 2 + 2;
        tree.resize(n, vector<ll>(alpha, -1));
        lo.resize(n), hi.resize(n, sz(s) - 1), par.resize(n), link.resize(n);
        cur_sz = 2, cur_node = 0, cur_pos = 0;
        // initialize data for the root of the tree
        link[0] = 1; lo[0] = hi[0] = lo[1] = hi[1] = -1;
        tree[1] = vector<ll>(alpha, 0);
        // add the text to the tree, letter by letter
        for (cur_ch = 0; cur_ch < sz(s); cur_ch++) add_char(ch_to_idx(s[cur_ch]));
    }
 
    ll ch_to_idx(ch c) {
        if (c == '$') return 26;
        else return c - 'a';
    }
 
    // add character c to the tree
    void add_char(ll c) {
        // we'll return here after each transition to the suffix (and will add character again)
        suff:;
        // check whether we're still within the boundaries of the current edge
        if (hi[cur_node] < cur_pos) {
            // if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree
            if (tree[cur_node][c] == -1) {
                tree[cur_node][c] = cur_sz;
                lo[cur_sz] = cur_ch;
                par[cur_sz++] = cur_node;
                cur_node = link[cur_node];
                cur_pos = hi[cur_node] + 1;
                goto suff;
            }
            cur_node = tree[cur_node][c];
            cur_pos = lo[cur_node];
        } // otherwise just proceed to the next edge
        // if the letter on the edge equal c, go down that edge
        if (cur_pos == -1 || c == ch_to_idx(s[cur_pos])) cur_pos++;
        else { 
            // otherwise split the edge in two with middle in node cur_sz
            lo[cur_sz] = lo[cur_node];
            hi[cur_sz] = cur_pos - 1;
            par[cur_sz] = par[cur_node];
            tree[cur_sz][ch_to_idx(s[cur_pos])] = cur_node;
            // add leaf cur_sz+1. It corresponds to transition through c.
            tree[cur_sz][c] = cur_sz + 1;
            lo[cur_sz + 1] = cur_ch;
            par[cur_sz + 1] = cur_sz;
            // update info for the current node - remember to mark cur_sz as parent of cur_node
            lo[cur_node] = cur_pos;
            par[cur_node] = cur_sz;
            tree[par[cur_sz]][ch_to_idx(s[lo[cur_sz]])] = cur_sz;
            cur_sz += 2;
            // prepare for descent
            // cur_pos will mark where are we in the current suffix
            cur_node = link[par[cur_sz - 2]];
            cur_pos = lo[cur_sz - 2];
            // while the current suffix is not over, descend
            while (cur_pos <= hi[cur_sz - 2]) {
                cur_node = tree[cur_node][ch_to_idx(s[cur_pos])];
                cur_pos += hi[cur_node] - lo[cur_node] + 1;
            }
            // if we're in a node, add a suffix link to it, otherwise add the link to cur_sz
            // (we'll create cur_sz on next iteration).
            if (cur_pos == hi[cur_sz - 2] + 1) link[cur_sz - 2] = cur_node;
            else link[cur_sz - 2] = cur_sz;
            // add cur_pos to the new edge and return to add letter to suffix
            cur_pos = hi[cur_node] - (cur_pos - hi[cur_sz - 2]) + 2;
            goto suff;
        }
    }

    void print() {
        FOR (i, cur_sz) {
            cout << i << ": [" << lo[i] << ", " << hi[i] << "] par: " << par[i] << " link: " << link[i] << '\n';
            FOR (j, alpha) {
                if (tree[i][j] != -1) {
                    if (j == 0) cout << "$ ";
                    else cout << (ch) ('a' + j - 1) << ' ';
                    cout << tree[i][j] << '\n';
                }
            }
        }
    }
};

ll gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth, ll v = 0, ll d = 0) {
    depth[v] = d;
    ll rv = 0;
    FOR (i, st.alpha) {
        if (st.tree[v][i] != -1) {
            rv += gen_tree(st, leafs, depth, st.tree[v][i], d + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1);
        }
    }
    if (rv == 0) {
        rv = 1;
    }
    leafs[v] = rv;
    return rv;
}

void gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth) {
    vector<ll> in(st.cur_size);
    queue<ll> depth_q, leaf_q;
    depth_q.push(0);
    while (!depth_q.empty()) {
        ll v = depth_q.front();
        depth_q.pop();
        bool is_leaf = true;
        FOR (i, st.alpha) {
            if (st.tree[v][i] != -1) {
                depth[st.tree[v][i]] = depth[v] + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1;
                depth_q.push(st.tree[v][i]);
                in[v]++;
                is_leaf = false;
            }
        }
        if (is_leaf) {
            leafs[v] = 1;
            leaf_q.push(v);
        }
    }
    while (!leaf_q.empty()) {
        ll v = leaf_q.front();
        leaf_q.pop();
        if (v != 0) {
            leafs[st.par[v]] += leafs[v];
            in[st.par[v]]--;
            if (in[st.par[v]] == 0) {
                leaf_q.push(st.par[v]);
            }
        }
    }
}

bool dfs(ll u, SuffixTree &st, str &s, str &rv, ll &n) {
    ll lo = 0, hi = -1;
    if (u) {
        lo = st.lo[u];
        hi = min(min(st.hi[u], sz(s) - 1), lo + n - 1);
    }
    n -= hi - lo + 1;
    if (n == 0) {
        rv = s.substr(lo, hi - lo + 1);
        return true;
    }
    FOR (i, 26) {
        ll &v = st.tree[u][i];
        if (v != -1 && dfs(v, st, s, rv, n)) {
            rv = s.substr(lo, hi - lo + 1) + rv;
            return true;
        }
    }
    return false;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    str s;
    cin >> s;
    SuffixTree st(s);
    vector<int> leafs(st.cur_size), depth(st.cur_size);
    gen_tree(st, leafs, depth);
    int k;
    cin >> k;

    while (k--) {
        str t;
        cin >> t;

        int i = 0, v = 0;
        if (st.tree[0][st.char_to_index(t[0])] == -1) {
            cout << 0 << '\n';
            continue;
        } else {
            v = st.tree[0][st.char_to_index(t[0])];
        }

        bool ok = true;
        int idx = 0;
        while (i < sz(t)) {
            int j = st.lo[v];
            while (j <= st.hi[v] && i < sz(t) && t[i] == s[j]) {
                i++;
                j++;
            }
            if (i == sz(t)) {
                idx = j - sz(t) + 1;
                break;
            }
            if (j > st.hi[v]) {
                if (st.tree[v][st.char_to_index(t[i])] == -1) {
                    ok = false;
                    break;
                } else {
                    v = st.tree[v][st.char_to_index(t[i])];
                }
            } else {
                ok = false;
                break;
            }
        }
    }

    return 0;
}

//--------------------------------------------------

vector<bool> vis(n); // Tarjan's Bridge Finding
vector<ll> tin(n), low(n);
ll timer = 0;
bool ok = true; // ok = false if bridge found
auto dfs = [&](auto &&self, ll u, ll p) -> void {
    vis[u] = true;
    tin[u] = low[u] = timer++;
    ll children = 1;
    FORE (v, adj[u]) {
        if (v == p) continue;
        if (vis[v]) low[u] = min(low[u], tin[v]);
        else {
            self(self, v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > tin[u]) {
            // *low[v] >= tin[u] && p != -1 means u is an articulation point
                ok = false;
            }
            children++;
        }
        if (!ok) return;
    }
    // *p == -1 && children > 1 ALSO means u is an articulation point
};

//--------------------------------------------------

struct Node {
    ll label, priority, size = 1, sum;
    bool rev = false;
    Node *child[2];
    Node(ll label) : label(label), priority(rng()), sum(label) {
        child[0] = child[1] = nullptr;
    }
};

struct Treap {
    Node *root = nullptr;

    ll cnt(Node *node) { return node ? node->size : 0; }

    void upd_cnt(Node *node)
    { if (node) node->size = cnt(node->child[0]) + cnt(node->child[1]) + 1; }

    ll sum(Node *node) { return node ? node->sum : 0; }

    void upd_sum(Node *node)
    { if (node) node->sum = sum(node->child[0]) + sum(node->child[1]) + node->label; }

    void push(Node *node) { // lazy propagation
        if (node && node->rev) {
            node->rev = false;
            swap(node->child[0], node->child[1]);
            if (node->child[0]) node->child[0]->rev ^= true;
            if (node->child[1]) node->child[1]->rev ^= true;
        }
    }

    void merge(Node *&node, Node *l, Node *r) { // merges l and r into node
        push(l), push(r);
        if (!l || !r) node = l ? l : r;
        elif (l->priority > r->priority) merge(l->child[1], l->child[1], r), node = l;
        else merge(r->child[0], l, r->child[0]), node = r;
        upd_cnt(node);
        upd_sum(node);
    }

    void split(Node *node, Node *&l, Node *&r, ll key, ll add = 0) { // splits node into l and r
        if (!node) return void(l = r = nullptr);
        push(node);
        ll cur_key = add + cnt(node->child[0]);
        if (key <= cur_key) split(node->child[0], l, node->child[0], key, add), r = node;
        else split(node->child[1], node->child[1], r, key, add + 1 + cnt(node->child[0])), l = node;
        upd_cnt(node);
        upd_sum(node);
    }

    void reverse(Node *node, ll l, ll r) { // reverses [l, r]
        Node *t1, *t2, *t3;
        split(node, t1, t2, l);
        split(t2, t2, t3, r - l + 1);
        t2->rev ^= true;
        merge(node, t1, t2);
        merge(node, node, t3);
    }

    void output(Node *node) { // inorder traversal
        if (!node) return;
        push(node);
        output(node->child[0]);
        cout << node->label;
        output(node->child[1]);
    }
};

//--------------------------------------------------

void make_clockwise(vector<pair<ld, ld>> &points) {
    pair<ld, ld> center = mp(0, 0);
    FORE (p, points) {
        center.first += p.first;
        center.second += p.second;
    }
    center.first /= sz(points);
    center.second /= sz(points);
    sort(all(points), [center](pair<ld, ld> &p1, pair<ld, ld> &p2) {
        return atan2(p1.second - center.second, p1.first - center.first) <
               atan2(p2.second - center.second, p2.first - center.first);
    });
}

bool in_triangle(pair<ld, ld> &point, vector<pair<ld, ld>> &triangle) {
    vector<ld> d(3);
    FOR (i, 3) {
        auto &p1 = triangle[i];
        auto &p2 = triangle[(i + 1) % 3];
        d[i] = (p2.first - p1.first) * (point.second - p1.second) -
            (p2.second - p1.second) * (point.first - p1.first);
    }
    return (d[0] >= 0 && d[1] >= 0 && d[2] >= 0) || (d[0] <= 0 && d[1] <= 0 && d[2] <= 0);
}

//--------------------------------------------------

constexpr ll ALPHA = 26;

struct Trie {
    ch c;
    bool ending = false;
    vector<Trie*> children = vector<Trie*>(ALPHA, nullptr);

    Trie(ch c_) : c(c_) {}

    void insert(ll i, str &s) {
        if (i == sz(s)) {
            ending = true;
            return;
        }
        ll si = s[i] - 'a';
        if (children[si] == nullptr) {
            children[si] = new Trie(s[i]);
        }
        children[si]->insert(i + 1, s);
    }
};