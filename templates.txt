#include <bits/stdc++.h>
using namespace std;

typedef long long ll;
typedef unsigned long long ull;
typedef pair<ll, ll> pll;
typedef complex<long double> cd;
typedef long double ld;
typedef pair<ld, ld> pld;
typedef char ch;
typedef string str;

mt19937 rng(chrono::steady_clock::now().time_since_epoch().count());

#include <bits/extc++.h>
using namespace __gnu_pbds;

template<typename T>
using indexed_set = tree<
    T,
    null_type,
    less<T>,
    rb_tree_tag,
    tree_order_statistics_node_update>;
// indexed_set s; (change pll above to desired type)
// s.order_of_key(x) -> number of elements < x
// s.find_by_order(x) -> iterator to the x-th element (0-indexed)

#pragma GCC target("popcnt,lzcnt")
// __builtin_popcount(x) -> number of set bits
// __builtin_clz(x) -> number of leading zeros
// for ll, use __builtin_popcountll, __builtin_clzll

#define pb push_back
#define elif else if
#define sz(C) (ll) C.size()
#define all(C) C.begin(), C.end()
#define flip(C) reverse(all(C))
#define ssort(C) sort(all(C))
#define rsort(C) sort(all(C), greater<>())

int main() {
    ios_base::sync_with_stdio(0);
    cin.tie(0), cout.tie(0);
    auto start = chrono::steady_clock::now();
    auto end = chrono::steady_clock::now();
    double diff = chrono::duration<double, milli>(end - start).count();
}

// Run -> Add configuration... -> in launch.json:
// "program": "${fileDirname}/${fileBasenameNoExtension}",
// "preLaunchTask": "C/C++: g++ build active file",

//--------------------------------------------------

// bellman_ford
    dist[v] = 0;
    FOR (i, n - 1)
        for (auto [a, b, w] : edges)
            if (dist[a] != INF && dist[a] + w < dist[b])
                dist[b] = dist[a] + w;

// dijkstra
    std::priority_queue<pll, vector<pll>, greater<>> pq;
    pq.push({0, v0});
    while (!pq.empty()) {
        auto [d, u] = pq.top(); pq.pop();
        if (d > dist[u]) continue;
        FORE (elem, adj[u]) {
            auto [v, w] = elem;
            if (dist[v] > dist[u] + w) {
                dist[v] = dist[u] + w;
                pq.push({dist[v], v});
            }
        }
    }

// floyd warshall
    FOR (k, n) FOR (i, n) FOR (j, n)
        dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);

//--------------------------------------------------

// find last, binary search
while (lo < hi) {
    ll mid = (lo + hi + 1) / 2;
    if (valid(mid)) lo = mid;
    else hi = mid - 1;
}

// find first, binary search
while (lo < hi) {
    ll mid = (lo + hi) / 2;
    if (valid(mid)) hi = mid;
    else lo = mid + 1;
}

//--------------------------------------------------

// maximal matching - left side: [0, lhs_cnt), right side: [0, rhs_cnt)
vector<ll> matching(rhs_cnt, -1);
vector<bool> vis_lhs(lhs_cnt), vis_rhs(rhs_cnt);

FOR (u, lhs_cnt) {
    for (ll v : adj[u]) {
        if (matching[v] == -1) {
            matching[v] = u;
            vis_lhs[u] = true;
            break;
        }
    }
}

function<bool(ll)> bpm = [&](ll u) {
    for (ll v : adj[u]) {
        if (!vis_rhs[v]) {
            vis_rhs[v] = true;
            if (matching[v] == -1 || bpm(matching[v])) {
                matching[v] = u;
                return true;
            }
        }
    }
    return false;
};

FOR (u, lhs_cnt) if (!vis_lhs[u]) {
    fill(all(vis_rhs), false);
    bpm(u);
}

//--------------------------------------------------

struct BIT {
    vector<ll> tree; ll n;
    BIT(ll n) : n(n) { tree.resize(n + 1); }
    void upd(ll idx, ll val) {
        idx++;
        while (idx <= n)
        { tree[idx] += val; idx += idx & (-idx); }
    }
    ll qry(ll idx) {
        idx++; ll sum = 0;
        while (idx > 0)
        { sum += tree[idx]; idx -= idx & (-idx); }
        return sum;
    }
    ll qry(ll l, ll r) { return qry(r) - qry(l - 1); } // [l, r]
};

struct BIT2d {
    vector<BIT> tree;
    ll n, m;
    BIT2d(ll n, ll m) : n(n), m(m) { tree.resize(n + 1, BIT(m)); }
    void upd(ll x, ll y, ll val) {
        x++;
        while (x <= n)
        { tree[x].upd(y, val); x += x & (-x); }
    }
    ll qry(ll x, ll y) {
        x++; ll sum = 0;
        while (x > 0) { sum += tree[x].query(y); x -= x & (-x); }
        return sum;
    }
    ll qry(ll x1, ll y1, ll x2, ll y2)
    { return qry(x2, y2) - qry(x1 - 1, y2) - qry(x2, y1 - 1) + qry(x1 - 1, y1 - 1); }
};

//--------------------------------------------------

pld get_com(vector<pld> &poly) {
    ld x = 0, y = 0;
    ld area = 0;
    FOR (i, sz(poly)) {
        ll j = (i + 1) % sz(poly);
        ld a = poly[i].x * poly[j].y - poly[j].x * poly[i].y;
        area += a;
        x += (poly[i].x + poly[j].x) * a;
        y += (poly[i].y + poly[j].y) * a;
    }
    area /= 2;
    x /= 6 * area;
    y /= 6 * area;
    return {x, y};
}

//--------------------------------------------------

struct Point {
    ld x, y;
    Point operator+(Point o) { return {x + o.x, y + o.y}; }
    Point operator-(Point o) { return {x - o.x, y - o.y}; }
    Point operator*(ld k)    { return {x * k, y * k}; }
    Point operator/(ld k)    { return {x / k, y / k}; }
    ld abs2()                { return x * x + y * y; }
    ld abs_()                { return sqrt(abs2()); }
    bool operator==(Point o)
    { return abs(x - o.x) < EPS && abs(y - o.y) < EPS; }
    bool operator!=(Point o)
    { return abs(x - o.x) > EPS || abs(y - o.y) > EPS; }
};

struct Circle {
    Point c; ld r; ll id;
    Circle(Point c, ld r, ll id) : c(c), r(r), id(id) {}
    Circle() {}
    bool has(Point &p)       { return (p - c).abs_() <= r + EPS; }
    vector<Point> operator&(Circle &o) {
        if ((c - o.c).abs_() > r + o.r + EPS || (c - o.c).abs_() < abs(r - o.r) - EPS)
            return {};
        if ((c - o.c).abs_() < EPS && abs(r - o.r) < EPS)
            return {{c.x + r, c.y}};
        Point sum = o.c + c, diff = o.c - c, perp = {diff.y, -diff.x};
        ld csu = 0.5,
            cdi = (r * r - o.r * o.r) / (2 * diff.abs2()),
            cpe = 0.5 * sqrt(max((ld) 0, 2 * (r * r + o.r * o.r) / (diff.abs2())
                - (r * r - o.r * o.r) * (r * r - o.r * o.r) / (diff.abs2() * diff.abs2()) - 1));
        vector<Point> rv = {sum * csu + diff * cdi + perp * cpe, sum * csu + diff * cdi - perp * cpe};
        return rv;
    }
};

//--------------------------------------------------

vector<pll> convex_hull(vector<pll> pts) { // returns ccw convex hull
    if (sz(pts) <= 1) return pts;
    ssort(pts);
    vector<pll> lo, hi;
    FORE (p, pts) {
        while (sz(lo) >= 2) {
            auto &p1 = lo[sz(lo) - 2], &p2 = lo[sz(lo) - 1];
            if ((p2.y - p1.y) * (p.x - p2.x) >= (p.y - p2.y) * (p2.x - p1.x)) {
                lo.pop_back();
            } else break;
        }
        lo.pb(p);
    }
    for (auto it = pts.rbegin(); it != pts.rend(); it++) {
        auto &p = *it;
        while (sz(hi) >= 2) {
            auto &p1 = hi[sz(hi) - 2], &p2 = hi[sz(hi) - 1];
            if ((p2.y - p1.y) * (p.x - p2.x) >= (p.y - p2.y) * (p2.x - p1.x)) {
                hi.pop_back();
            } else break;
        }
        hi.pb(p);
    }
    lo.pop_back(), hi.pop_back();
    lo.insert(lo.end(), hi.begin(), hi.end());
    return lo;
}

//--------------------------------------------------

sort(all(x), [](ll a, ll b) {
    return a < b;
}); // equivalent to regular sort

sort(all(pts), [](pll a, pll b) {
    return a.x * b.y > a.y * b.x;
}); // sort by a.x / a.y (ascending)

//--------------------------------------------------

struct Edge { ll s, t, cap = 0, cost = 0, flow = 0; };

struct Dinic {
    ll n; vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> lvl, ptr;
    queue<ll> q;

    Dinic(ll n, vector<Edge> &edges0) :
        n(n), adj(n), lvl(n), ptr(n) {
        FORE (e, edges0) {
            adj[e.s].pb(sz(edges));
            edges.pb(e);
            adj[e.t].pb(sz(edges));
            edges.pb({e.t, e.s});
        }
    }

    bool bfs(ll s, ll t) {
        lvl.assign(n, -1); lvl[s] = 0; q.push(s);
        while (!q.empty()) {
            ll v = q.front(); q.pop();
            FORE (e, adj[v]) {
                ll u = edges[e].t;
                if (lvl[u] != -1 || edges[e].cap <= edges[e].flow) continue;
                lvl[u] = lvl[v] + 1;
                q.push(u);
            }
        }
        return lvl[t] != -1;
    }

    ll dfs(ll v, ll t, ll f) {
        if (v == t || f == 0) return f;
        for (ll &cid = ptr[v]; cid < sz(adj[v]); cid++) {
            ll e = adj[v][cid], u = edges[e].t;
            if (lvl[v] + 1 != lvl[u]) continue;
            ll pushed = dfs(u, t, min(f, edges[e].cap - edges[e].flow));
            if (pushed) {
                edges[e].flow += pushed;
                edges[e ^ 1].flow -= pushed;
                return pushed;
            }
        }
        return 0;
    }

    ll max_flow(ll s, ll t) {
        ll flow = 0;
        while (bfs(s, t)) {
            ptr.assign(n, 0);
            while (ll pushed = dfs(s, t, INF)) flow += pushed;
        }
        return flow;
    }

    vector<pll> min_cut(ll s) {
        bfs(s, n - 1);
        vector<pll> cut;
        FORE (e,edges) if (lvl[e.s] != -1 && lvl[e.t] == -1 && e.cap > 0)
            cut.pb({e.s, e.t});
        return cut;
    }

    void undo_flow(vector<ll> path, ll f) {
        FOR (i, sz(path) - 1) {
            FORE (e, adj[path[i]]) {
                if (edges[e].t == path[i + 1]) {
                    edges[e].flow -= f;
                    edges[e ^ 1].flow += f;
                    assert(edges[e].flow <= edges[e].cap);
                    assert(edges[e ^ 1].flow <= edges[e ^ 1].cap);
                    break;
                }
            }
        }
    }
};

struct MinCostMaxFlow {
    ll n, m; vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> dist, pi, vis;
    vector<pll> par;

    MinCostMaxFlow(ll n, vector<Edge> &edges0) :
        n(n), m(sz(edges0)), adj(n),
        vis(n), dist(n), pi(n), par(n) {
        FORE (e, edges0) {
            adj[e.s].pb(sz(edges));
            edges.pb(e);
            adj[e.t].pb(sz(edges));
            edges.pb({e.t, e.s});
        }
    }

    void path(ll s) {
        vis.assign(n, false);
        dist.assign(n, INF);
        dist[s] = 0; ll di;

        __gnu_pbds::priority_queue<pll, greater<>> pq;
        vector<decltype(pq)::point_iterator> its(n);
        pq.push({0, s});

        auto relax = [&](ll t, ll e, ll cap, ll cost, ll dir) {
            ll val = di - pi[t] + cost;
            if (cap && val < dist[t]) {
                dist[t] = val;
                par[t] = {e, dir};
                if (its[t] == pq.end()) its[t] = pq.push({val, t});
                else pq.modify(its[t], {val, t});
            }
        };

        while (!pq.empty()) {
            s = pq.top().s; pq.pop();
            vis[s] = 1; di = dist[s] + pi[s];
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) relax(t, e, edges[e].cap - edges[e].flow, edges[e].cost, 1);
            }
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) relax(t, e, edges[e ^ 1].flow, -edges[e ^ 1].cost, 0);
            }
        }

        FOR (i, n) pi[i] = min(pi[i] + dist[i], INF);
    }

    pll max_flow(ll s, ll t) {
        ll flow = 0, cost = 0;
        while (path(s), vis[t]) {
            ll f = INF;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                f = min(f, r ? edges[p].cap - edges[p].flow : edges[p ^ 1].flow);
            }
            flow += f;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                if (r) edges[p].flow += f;
                else edges[p ^ 1].flow -= f;
            }
        }
        FORE (e, edges) cost += e.flow * e.cost;
        return {flow, cost};
    }

    void set_pi(ll s) { // for negative costs
        pi.assign(n, INF); pi[s] = 0;
        ll it = n, ch = 1, v;
        while (ch-- && it--) {
            FOR (i, n) {
                if (pi[i] == INF) continue;
                FORE (e, adj[i]) {
                    if (edges[e].cap && (v = pi[i] + edges[e].cost) < pi[edges[e].t]) {
                        pi[edges[e].t] = v;
                        ch = 1;
                    }
                }
            }
        }
        assert(it >= 0);
    }
};

//--------------------------------------------------

struct DSU {
    ll cnt; vector<ll> e;
    DSU(ll n) : cnt(n), e(n, -1) {}
    void reset() { e = vector<ll>(sz(e), -1); cnt = sz(e); }
    ll get(ll x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
    bool same_set(ll a, ll b) { return get(a) == get(b); }
    ll size(ll x) { return -e[get(x)]; }
    bool unite(ll x, ll y) {
        x = get(x), y = get(y);
        if (x == y) return false;
        if (e[x] > e[y]) swap(x, y);
        e[x] += e[y]; e[y] = x;
        cnt--;
        return true;
    }
};

//--------------------------------------------------

constexpr ll MOD = 1e9 + 7;

struct Binom {
    ll n;
    vector<ll> fac, ifac;
    vector<vector<ll>> stirling;
    Binom(ll n) : n(n), fac(n + 1), ifac(n + 1), stirling(n + 1, vector<ll>(n + 1)) {
        fac[0] = 1;
        FOB (i, 1, n + 1) fac[i] = fac[i - 1] * i % MOD;
        ifac[n] = poww(fac[n], MOD - 2);
        FORR (i, n) ifac[i] = ifac[i + 1] * (i + 1) % MOD;
        stirling[0][0] = 1;
        FOB (i, 1, n + 1) FOB (j, 1, i + 1)
            stirling[i][j] = (stirling[i - 1][j - 1] + (i - 1) * stirling[i - 1][j]) % MOD;
    }
    ll poww(ll a, ll b) {
        ll rv = 1;
        while (b) {
            if (b & 1) rv = rv * a % MOD;
            a = a * a % MOD;
            b >>= 1;
        }
        return rv;
    }
    ll choose(ll n, ll k) {
        if (k < 0 || k > n) return 0;
        else return fac[n] * ifac[k] % MOD * ifac[n - k] % MOD;
    }
    ll stirling1(ll n, ll k) {
        return abs(stirling[n][k]);
    }
};

//--------------------------------------------------

// ll n = sz(s), n2 = 1LL << (64 - __builtin_clzll(n));
// vector<cd> a(n2), b(n2);
// ...init a, b...
// fft(a, false);
// fft(b, false);
// FOR (i, n) a[i] *= b[i];
// fft(a, true);

void fft(vector<cd> &a, bool inv) {
    int n = sz(a);
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        ld ang = 2 * M_PI / len * (inv ? -1 : 1);
        cd wlen(cos(ang), sin(ang));
        for (int i = 0; i < n; i += len) {
            cd w(1);
            for (int j = 0; j < len / 2; j++) {
                cd u = a[i + j], v = a[i + j + len / 2] * w;
                a[i + j] = u + v;
                a[i + j + len / 2] = u - v;
                w *= wlen;
            }
        }
    }
    if (inv) FORE (x, a) x /= n;
}

const int MOD = 7340033;
const int ROOT = 5;
const int ROOT_1 = 4404020; // 5*4404020 = 1 (mod MOD)
const int ROOT_PW = 1 << 20; // 5^(2^20) = 1 (mod MOD)

void fft(vector<int> &a, bool invert) {
    int n = sz(a);
    for (int i = 1, j = 0; i < n; i++) {
        int bit = n >> 1;
        for (; j & bit; bit >>= 1) j ^= bit;
        j ^= bit;
        if (i < j) swap(a[i], a[j]);
    }
    for (int len = 2; len <= n; len <<= 1) {
        int wlen = invert ? ROOT_1 : ROOT;
        for (int i = len; i < ROOT_PW; i <<= 1)
            wlen = (int)(1LL * wlen * wlen % MOD);
        for (int i = 0; i < n; i += len) {
            int w = 1;
            for (int j = 0; j < len / 2; j++) {
                int u = a[i+j], v = (int)(1LL * a[i+j+len/2] * w % MOD);
                a[i+j] = u + v < MOD ? u + v : u + v - MOD;
                a[i+j+len/2] = u - v >= 0 ? u - v : u - v + MOD;
                w = (int)(1LL * w * wlen % MOD);
            }
        }
    }
    if (invert) {
        int n_1 = inverse(n, MOD);
        for (int & x : a) x = (int)(1LL * x * n_1 % MOD);
    }
}

//--------------------------------------------------

bool game(auto state, bool alice) {
    if (mem.find(state) != mem.end())
        return mem[state];
    FORE (move, valid_moves) {
        change_state();
        if (!game(state, !alice)) {
            restore_state();
            mem[state] = true;
            return true;
        }
        restore_state();
    }
    mem[state] = false;
    return false;
}

//--------------------------------------------------

vector<ll> get_kth_state(ll n, ll k) { // 1-indexed
    vector<ll> state(n);
    FOR (i, n) {
        FORE (choice, valid_choices) {
            apply(choice);
            ll cnt = count_states();
            if (cnt >= k) break;
            k -= cnt;
            undo(choice);
        }
        if (no choice made) return no solution;
    }
    return state;
}

//--------------------------------------------------

// returns 0 if no solution, 1 if unique solution, INF if infinite solutions
ll gauss_jordan(vector<vector<ld>> &A, vector<ld> &b, vector<ld> &x) { // A * x = b
    ll n = sz(A), m = sz(A[0]);
    vector<vector<ld>> a(n, vector<ld>(m + 1));
    FOR(i, n) {
        FOR(j, m) a[i][j] = A[i][j];
        a[i][m] = b[i];
    }
    vector<ll> where(m, -1);
    for (ll col = 0, row = 0; col < m && row < n; col++) {
        ll sel = row;
        FOB (i, row, n) if (abs(a[i][col]) > abs(a[sel][col])) sel = i;
        if (abs(a[sel][col]) < EPS) continue;
        FOB (i, col, m + 1) swap(a[sel][i], a[row][i]);
        where[col] = row;
        FOR (i, n) {
            if (i != row) {
                ld c = a[i][col] / a[row][col];
                FOB (j, col, m + 1) a[i][j] -= a[row][j] * c;
            }
        }
        row++;
    }
    x.assign(m, 0);
    FOR (i, m) if (where[i] != -1) x[i] = a[where[i]][m] / a[where[i]][i];
    FOR (i, n) {
        ld sum = 0;
        FOR (j, m) sum += a[i][j] * x[j];
        if (abs(sum - a[i][m]) > EPS) { // may need to change for modulo
            return 0;
        }
    }
    FOR (i, m) if (where[i] == -1) return INF;
    return 1;
}

int gauss_jordan_binary( // A * x = b
    vector<bitset<MAXN>> A,
    bitset<MAXN> &b,
    bitset<MAXN> &x,
    int n,
    int m
) {
    FOR (i, n) A[i][m] = b[i];
    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; col++) {
        FOB (i, row, n) {
            if (A[i][col] != 0)
            { swap(A[i], A[row]); break; }
        }
        if (A[row][col] == 0) continue;
        where[col] = row;
        FOR (i, n) if (i != row && A[i][col] != 0) A[i] ^= A[row];
        row++;
    }
    x = bitset<MAXN>(0);
    FOR (i, m) if (where[i] != -1) x[i] = A[where[i]][m] / A[where[i]][i];
    FOR (i, n) {
        int sum = 0;
        FOR (j, m) sum += A[i][j] * x[j];
        if (sum != A[i][m]) return 0;
    }
    FOR (i, m) if (where[i] == -1) return INF;
    return 1;
}

//--------------------------------------------------

ll gcd(ll a, ll b) {
    if (a == 0) return b;
    return gcd(b % a, a);
}

// a * x + b * y = gcd(a, b)
pll bezout(ll a, ll b) {
    if (a == 0) return {0, 1};
    auto [x, y] = bezout(b % a, a);
    return {y - (b / a) * x, x};
}

// x % m == a, x % n == b
// x % lcm(m, n) = -(a * v * n + b * u * m) / gcd(m, n)
ll crt(ll m, ll n, ll a, ll b) {
    ll g = gcd(m, n);
    if (a % g != b % g) return -1;
    ll lcm = m * n / g;
    auto [u, v] = bezout(m / g, n / g);
    ll k = (b - a) / g, x = (a + m * k * u) % lcm;
    if (x < 0) x += lcm;
    return x;
}

//--------------------------------------------------

// costs[i][j] = j-th worker's cost to do i-th job
vector<ll> hungarian(vector<vector<ll>> &costs) {
    ll J = sz(costs), W = sz(costs[0]); // |jobs| <= |workers|
    vector<ll> job(W + 1, -1), ys(J), yt(W + 1), rv;
    FOR (j_cur, J) {
        ll w_cur = W;
        job[w_cur] = j_cur;
        vector<ll> min_to(W + 1, INF), prev(W + 1, -1);
        vector<bool> in_Z(W + 1);
        while (job[w_cur] != -1) {
            in_Z[w_cur] = true;
            ll j = job[w_cur], del = INF, w_nxt;
            FOR (w, W) {
                if (!in_Z[w]) {
                    if (min_to[w] > costs[j][w] - ys[j] - yt[w]) {
                        min_to[w] = costs[j][w] - ys[j] - yt[w];
                        prev[w] = w_cur;
                    }
                    if (del > min_to[w]) {
                        del = min_to[w];
                        w_nxt = w;
                    }
                }
            }
            FOR (w, W + 1) {
                if (in_Z[w]) ys[job[w]] += del, yt[w] -= del;
                else min_to[w] -= del;
            }
            w_cur = w_nxt;
        }
        for (ll w; w_cur != W; w_cur = w) job[w_cur] = job[w = prev[w_cur]];
        rv.pb(-yt[W]);
    }
    return rv;
}

//--------------------------------------------------

struct LCA {
    vector<vector<ll>> parent, adj;
    vector<ll> pre, post, depth;
    ll n, timer;
    LCA(ll &n0, vector<vector<ll>> &adj0) {
        n = n0;
        timer = 0;
        pre = vector<ll>(n), post = pre, depth = pre;
        parent = vector<vector<ll>>(n, vector<ll>(30));
        adj = adj0; dfs(0, 0, 0); gen();
    }
    void dfs(ll node, ll par, ll d) {
        pre[node] = timer++;
        depth[node] = d;
        parent[node][0] = par;
        FORE (child, adj[node]) if (child != par) dfs(child, node, d + 1);
        post[node] = timer++;
    }
    void gen()
    { FOR (i, 29) FOR (j, n) parent[j][i + 1] = parent[parent[j][i]][i]; }
    bool is_anc(ll u, ll v) // is u an ancestor of v?
    { return pre[u] <= pre[v] && post[u] >= post[v]; }
    ll lca(ll u, ll v) {
        if (is_anc(u, v)) return u;
        if (is_anc(v, u)) return v;
        FORR (i, 30) if (!is_anc(parent[u][i], v)) u = parent[u][i];
        return parent[u][0];
    }
    ll dist(ll u, ll v)
    { return depth[u] + depth[v] - 2 * depth[lca(u, v)]; }
    bool disjoint(vector<pll> paths) {
        vector<pll> p;
        FORE (path, paths) {
            ll u, v;
            tie(u, v) = path;
            ll w = lca(u, v);
            p.pb({w, u});
            p.pb({w, v});
        }
        FOR (i, sz(p)) FOR (j, i - i % 2) 
            if (!(lca(p[i].s, p[j].f) != p[j].f ||
                lca(p[j].s, p[i].f) != p[i].f)) return false;
        return true;
    }
};

//--------------------------------------------------

vector<ll> lis(vector<ll> a) {
    ll n = sz(a);
    vector<ll> d(n + 1, INF), p(n + 1);
    d[0] = -INF;
    FOR (i, n) {
        ll j = upper_bound(all(d), a[i]) - d.begin();
        if (d[j - 1] < a[i] && a[i] < d[j]) {
            d[j] = a[i];
            p[i] = j;
        }
    }
    ll len = 0;
    FOR (i, n + 1) if (d[i] < INF) len = i;
    vector<ll> ans(len);
    ll cur = INF;
    FORR (i, n) if (p[i] == len) {
        ans[--len] = a[i];
        cur = a[i];
    }
    return ans;
}

//--------------------------------------------------

pll manacher(str &s) { // largest palindrome, returns {len, idx}
    str t = "$#";
    FORE (c, s) { t += c; t += '#'; }
    ll n = sz(t);
    ll center = 0, max_rad = -1, rad;
    vector<ll> p(n);
    FOR (i, n) {
        if (i <= max_rad) rad = min(p[2 * center - i], max_rad - i);
        else rad = 0;
        while (i - rad - 1 >= 0 && i + rad + 1 < n && t[i - rad - 1] == t[i + rad + 1]) rad++;
        p[i] = rad;
        if (i + rad > max_rad) {
            center = i;
            max_rad = i + rad;
        }
    }
    ll len = 0, idx = 0;
    FOR (i, n) if (p[i] > len) {
        len = p[i];
        idx = i;
    }
    return {len, (idx - len) / 2};
}

//--------------------------------------------------

struct Matrix { // mat[i] is row i
    vector<vector<ll>> mat;
    ll n, m;
    Matrix(ll n, ll m) : n(n), m(m) { mat.resize(n, vector<ll>(m)); }
    Matrix operator*(const Matrix &other) const {
        Matrix rv(n, other.m);
        FOR(i, n) FOR(j, other.m) FOR(k, m)
            rv.mat[i][j] += mat[i][k] * other.mat[k][j];
        return rv;
    }
    Matrix operator^(ll p) const {
        Matrix rv(n, n);
        FOR(i, n) rv.mat[i][i] = 1;
        Matrix a = *this;
        while (p) {
            if (p & 1) rv = rv * a;
            a = a * a;
            p >>= 1;
        }
        return rv;
    }
    ld det() const {
        Matrix a = *this;
        ld rv = 1;
        FOR(i, n) {
            ll p = i;
            FOB(j, i + 1, n) if (abs(a.mat[j][i]) > abs(a.mat[p][i])) p = j;
            if (p != i) {
                swap(a.mat[i], a.mat[p]);
                rv *= -1;
            }
            if (abs(a.mat[i][i]) < 1e-9) return 0;
            rv *= a.mat[i][i];
            FOB(j, i + 1, n) {
                ld c = a.mat[j][i] / a.mat[i][i];
                FOB(k, i, n) a.mat[j][k] -= c * a.mat[i][k];
            }
        }
        return rv;
    }
    Matrix inv() const {
        Matrix a = *this, rv(n, n);
        FOR(i, n) rv.mat[i][i] = 1;
        FOR(i, n) {
            ll p = i;
            FOB(j, i + 1, n) if (abs(a.mat[j][i]) > abs(a.mat[p][i])) p = j;
            if (p != i) {
                swap(a.mat[i], a.mat[p]);
                swap(rv.mat[i], rv.mat[p]);
            }
            ld c = a.mat[i][i];
            FOR(j, n) a.mat[i][j] /= c, rv.mat[i][j] /= c;
            FOR(j, n) if (j != i) {
                c = a.mat[j][i];
                FOR(k, n) a.mat[j][k] -= c * a.mat[i][k], rv.mat[j][k] -= c * rv.mat[i][k];
            }
        }
        return rv;
    }
    // min dist
    Matrix operator*(const Matrix &other) const {
        Matrix rv(n, other.m);
        rv.mat.assign(n, vector<ll>(other.m, INF));
        FOR(i, n) FOR(j, other.m) FOR(k, m)
            rv.mat[i][j] = min(rv.mat[i][j], mat[i][k] + other.mat[k][j]);
        return rv;
    }
    Matrix operator^(ll p) const {
        Matrix rv(n, n);
        rv.mat.assign(n, vector<ll>(n, INF));
        FOR (i, n) rv.mat[i][i] = 0;
        Matrix a = *this;
        while (p) {
            if (p & 1) rv = rv * a;
            a = a * a;
            p >>= 1;
        }
        return rv;
    }
};

//--------------------------------------------------

struct mll {
    ll v;
    mll(): v(0) {}
    mll(ll _v) { v = (_v % MOD + MOD) % MOD; }
    explicit operator ll() const { return v; }
    mll& operator+=(const mll &o) { v += o.v; if (v >= MOD) v -= MOD; return *this; }
    mll& operator-=(const mll &o) { v -= o.v; if (v < 0) v += MOD; return *this; }
    mll& operator*=(const mll &o) { v = (ll)(v * o.v % MOD); return *this; }
    mll& operator/=(const mll &o) { return *this *= o.inv(); }
    friend mll operator+(mll a, const mll &b) { return a += b; }
    friend mll operator-(mll a, const mll &b) { return a -= b; }
    friend mll operator*(mll a, const mll &b) { return a *= b; }
    friend mll operator/(mll a, const mll &b) { return a /= b; }
    mll operator-() const { return mll(-v); }
    bool operator==(const mll &o) const { return v == o.v; }
    bool operator!=(const mll &o) const { return v != o.v; }
    static mll pow(mll a, ll e) {
        mll r = 1;
        while (e > 0) {
            if (e & 1) r *= a;
            a *= a;
            e >>= 1;
        }
        return r;
    }
    mll inv() const { return pow(*this, MOD - 2); }
    friend ostream& operator<<(ostream &os, const mll &m) { return os << m.v; }
    friend istream& operator>>(istream &is, mll &m) { ll x; is >> x; m = mll(x); return is; }
};

//--------------------------------------------------

ll poww(ll x, ll p) {
    ll rv = 1;
    while (p) {
        if(p & 1) rv *= x;
        x *= x; p >>= 1;
    }
    return rv;
}

//--------------------------------------------------

struct SCCs {
    ll n, idx, scc_cnt;
    vector<vector<ll>> adj;
    vector<set<ll>> adj_scc; // [0]: snk, [-1]: src
    vector<ll> ord, low, ids;
    vector<bitset<50000>> dp; // max scc_cnt = 50000
    vector<bool> on_stack;
    stack<ll> stk;

    SCCs(ll n0, vector<vector<ll>> &adj0) {
        n = n0, idx = 0, scc_cnt = 0;
        adj = adj0;
        ord = vector<ll>(n, -1);
        low = vector<ll>(n, -1);
        ids = vector<ll>(n, -1);
        on_stack = vector<bool>(n, false);
        FOR (u, n) if (ord[u] == -1) dfs(u);
        adj_scc = vector<set<ll>>(scc_cnt);
        FOR (u, n) for (ll v : adj[u]) if (ids[u] != ids[v]) {
            adj_scc[ids[u]].insert(ids[v]);
        }
        vector<bool> vis(scc_cnt, false);
        dp = vector<bitset<50000>>(scc_cnt);
        FOR (u, scc_cnt) if (!vis[u]) dfs2(u, vis);
    }

    void dfs2(ll u, vector<bool> &vis) {
        vis[u] = true;
        for (ll v : adj_scc[u]) {
            if (!vis[v]) dfs2(v, vis);
            dp[u] |= dp[v];
        }
        dp[u][u] = 1;
    }

    bool u_to_v(ll u, ll v) {
        u = ids[u], v = ids[v];
        return dp[u][v];
    }

    void dfs(ll u) {
        ord[u] = low[u] = idx++;
        stk.push(u);
        on_stack[u] = true;
        for (ll v : adj[u]) {
            if (ord[v] == -1) dfs(v), low[u] = min(low[u], low[v]);
            elif (on_stack[v]) low[u] = min(low[u], ord[v]);
        }
        if (low[u] == ord[u]) {
            while (true) {
                ll v = stk.top();
                stk.pop();
                ids[v] = scc_cnt;
                on_stack[v] = false;
                if (u == v) break;
            }
            scc_cnt++;
        }
    }
};

//--------------------------------------------------

struct SegTree {
    ll n; vector<ll> data, lazy;
    SegTree (ll n, vector<ll> &raw) : n(n), data(4 * n), lazy(4 * n)
        { build(raw); }
    ll build(vector<ll> &raw, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) r = n;
        if (r - l == 1) return data[i] = raw[l];
        ll m = (l + r) / 2;
        return data[i] = build(raw, 2 * i, l, m) + build(raw, 2 * i + 1, m, r);
    }
    void fill(vector<ll> &vec, ll i = 1, ll l = 0, ll r = -1) {
        assert(sz(vec) == n);
        if (r == -1) r = n; push(i, l, r);
        if (r - l == 1) vec[l] = data[i];
        else {
            ll m = (l + r) / 2;
            fill(vec, 2 * i, l, m);
            fill(vec, 2 * i + 1, m, r);
        }
        return;
    }
    void push(ll i, ll l, ll r) {
        data[i] += (r - l) * lazy[i];
        if (r - l > 1) {
            lazy[2 * i] += lazy[i];
            lazy[2 * i + 1] += lazy[i];
        }
        lazy[i] = 0;
    }
    void upd(ll ul, ll ur, ll val, ll i = 1, ll l = 0, ll r = -1) { // [ul, ur)
        if (r == -1) r = n; push(i, l, r);
        if (ur <= l || r <= ul) return;
        if (ul <= l && r <= ur) {
            lazy[i] += val;
            push(i, l, r);
            return;
        }
        ll m = (l + r) / 2;
        upd(ul, ur, val, 2 * i, l, m);
        upd(ul, ur, val, 2 * i + 1, m, r);
        data[i] = data[2 * i] + data[2 * i + 1];
    }
    void updi(ll ui, ll val, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) r = n; push(i, l, r);
        if (r - l == 1) { data[i] = val; return; }
        ll m = (l + r) / 2;
        if (ui < m) updi(ui, val, 2 * i, l, m);
        else updi(ui, val, 2 * i + 1, m, r);
        data[i] = data[2 * i] + data[2 * i + 1];
    }
    ll qry(ll ql, ll qr, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) r = n; push(i, l, r);
        if (qr <= l || r <= ql) return 0;
        if (ql <= l && r <= qr) return data[i];
        ll m = (l + r) / 2;
        return qry(ql, qr, 2 * i, l, m) + qry(ql, qr, 2 * i + 1, m, r);
    }
};

//--------------------------------------------------

struct Vertex { // persistent segtree, sum
    Vertex *l, *r;
    ll sum;
    Vertex(ll val) : l(nullptr), r(nullptr), sum(val) {}
    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {
        if (l) sum += l->sum;
        if (r) sum += r->sum;
    }
};

Vertex* build(vector<ll> &a, ll tl, ll tr) { // [tl, tr]
    if (tl == tr) return new Vertex(a[tl]);
    ll tm = (tl + tr) / 2;
    return new Vertex(build(a, tl, tm), build(a, tm + 1, tr));
}

ll get_sum(Vertex* v, ll tl, ll tr, ll l, ll r) { // [tl, tr] = [0, n - 1], [l, r]
    if (l > r) return 0;
    if (l == tl && tr == r) return v->sum;
    ll tm = (tl + tr) / 2;
    return get_sum(v->l, tl, tm, l, min(r, tm))
         + get_sum(v->r, tm + 1, tr, max(l, tm + 1), r);
}

Vertex* update(Vertex* v, ll tl, ll tr, ll pos, ll new_val) { // [tl, tr] = [0, n - 1]
    if (tl == tr) return new Vertex(new_val);
    ll tm = (tl + tr) / 2;
    if (pos <= tm) return new Vertex(update(v->l, tl, tm, pos, new_val), v->r);
    else return new Vertex(v->l, update(v->r, tm + 1, tr, pos, new_val));
}

//--------------------------------------------------

struct Vertex { // dynamic segtree, sum
    ll left, right;
    ll sum = 0;
    Vertex *left_child = nullptr, *right_child = nullptr;

    Vertex(ll lb, ll rb) {
        left = lb;
        right = rb;
    }

    void extend() {
        if (!left_child && left + 1 < right) {
            ll t = (left + right) / 2;
            left_child = new Vertex(left, t);
            right_child = new Vertex(t, right);
        }
    }

    void add(ll k, ll x) {
        extend();
        sum += x;
        if (left_child) {
            if (k < left_child->right)
                left_child->add(k, x);
            else
                right_child->add(k, x);
        }
    }

    ll get_sum(ll lq, ll rq) {
        if (lq <= left && right <= rq)
            return sum;
        if (max(left, lq) >= min(right, rq))
            return 0;
        extend();
        return left_child->get_sum(lq, rq) + right_child->get_sum(lq, rq);
    }
};

//--------------------------------------------------

ld shoelace(vector<pld> &v) {
    ld rv = 0;
    FOR (i, sz(v))
    { rv += (v[i].x * v[(i + 1) % sz(v)].y) -
            (v[i].y * v[(i + 1) % sz(v)].x); }
    return abs(rv) / 2;
}

//--------------------------------------------------

struct Simplex {
    ll m, n;
    vector<ll> N, B;
    vector<vector<ld>> D;

    // Ax <= b, max c.x with x >= 0
    Simplex(vector<vector<ld>> &A, vector<ld> &b, vector<ld> &c) :
        m(sz(b)), n(sz(c)), N(n + 1), B(m), D(m + 2, vector<ld>(n + 2)) {
        FOR (i, m) FOR (j, n) D[i][j] = A[i][j];
        FOR (i, m) { B[i] = n + i; D[i][n] = -1; D[i][n + 1] = b[i]; }
        FOR (j, n) { N[j] = j; D[m][j] = -c[j]; }
        N[n] = -1; D[m + 1][n] = 1;
    }

    void pivot(ll r, ll s) {
        ld inv = 1 / D[r][s];
        FOR (i, m + 2) if (i != r) FOR (j, n + 2) if (j != s)
            D[i][j] -= D[r][j] * D[i][s] * inv;
        FOR (j, n + 2) if (j != s) D[r][j] *= inv;
        FOR (i, m + 2) if (i != r) D[i][s] *= -inv;
        D[r][s] = inv;
        swap(B[r], N[s]);
    }

    bool simplex(ll phase) {
        ll x = m + phase - 1;
        for (;;) {
            ll s = -1;
            FOR (j, n + 1) if (N[j] != -phase) {
                if (s == -1 || make_pair(D[x][j], N[j]) <
                    make_pair(D[x][s], N[s])) s = j;
            }
            if (D[x][s] >= -EPS) return true;
            ll r = -1;
            FOR (i, m) {
                if (D[i][s] <= EPS) continue;
                if (r == -1 || make_pair(D[i][n + 1] / D[i][s], B[i]) <
                    make_pair(D[r][n + 1] / D[r][s], B[r])) r = i;
            }
            if (r == -1) return false;
            pivot(r, s);
        }
    }

    ld solve(vector<ld> &x) {
        ll r = 0;
        FOB (i, 1, m) if (D[i][n + 1] < D[r][n + 1]) r = i;
        if (D[r][n + 1] < -EPS) {
            pivot(r, n);
            if (!simplex(2) || D[m + 1][n + 1] < -EPS) return -INF;
            FOR (i, m) if (B[i] == -1) {
                ll s = 0;
                FOB (j, 1, n + 1) if (D[i][j] < D[i][s]) s = j;
                pivot(i, s);
            }
        }
        bool ok = simplex(1); x = vector<ld>(n);
        FOR (i, m) if (B[i] < n) x[B[i]] = D[i][n + 1];
        return ok ? D[m][n + 1] : INF;
    }
};

//--------------------------------------------------

struct SuffixArray {
    ll n; str s;
    vector<ll> sa, lcp;

    SuffixArray(str &s) : n(sz(s) + 1), s(s + '$'), sa(n - 1), lcp(n - 1) {
        vector<pair<pll, ll>> suffs(n);
        FOR (i, n) suffs[i] = { { s[i], s[i] }, i };
        ssort(suffs);
        vector<ll> equiv(n);
        FOR1 (i, n) {
            auto [c_val, cs] = suffs[i];
            auto [p_val, ps] = suffs[i - 1];
            equiv[cs] = equiv[ps] + (c_val > p_val);
        }
        for (ll idx = 1; idx < n; idx *= 2) {
            for (auto &[val, s] : suffs)
                val = { equiv[s], equiv[(s + idx) % n] };
            radix_sort(suffs);
            FOR (i, n - 1) {
                auto [p_val, ps] = suffs[i];
                auto [c_val, cs] = suffs[i + 1];
                equiv[cs] = equiv[ps] + (c_val > p_val);
            }
        }
        // --- for lcp ---
        vector<ll> idxs(n);
        FOR (i, n) idxs[suffs[i].s] = i;
        ll start_at = 0;
        FOR (i, n - 1) {
            ll prv = suffs[idxs[i] - 1].s,
                cur = start_at;
            while (s[i + cur] == s[prv + cur]) cur++;
            lcp[idxs[i] - 1] = cur;
            start_at = max(0LL, cur - 1);
        }
        // ---------------
        n--; // account for $
        this->s.pop_back();
        FOR (i, n) sa[i] = suffs[i + 1].s;
    }

    void radix_sort(vector<pair<pll, ll>> &arr) {
        for (ll i : {2, 1}) {
            auto key = [&](const pair<pll, ll> &x) {
                return i == 1 ? x.f.f : x.f.s;
            };
            ll mx = 0;
            for (auto &i : arr) mx = max(mx, key(i));
            vector<ll> occs(mx + 1);
            for (auto &i : arr) occs[key(i)]++;
            vector<ll> start(mx + 1);
            FOR (i, mx) start[i + 1] = start[i] + occs[i];
            vector<pair<pll, ll>> new_arr(n);
            for (auto &i : arr) new_arr[start[key(i)]++] = i;
            arr = new_arr;
        }
    }

    // to get lcp of i-th and j-th suffixes, use RMQ
};

//--------------------------------------------------

struct SuffixTree {
    str s; // input string for which the suffix tree is being built
    vector<vector<ll>> tree; // array of transitions (state, letter)
    // left... and right boundaries of the substring of s which correspond to incoming edge
    // parent of the node
    // suffix link
    vector<ll> lo, hi, par, link;
    // maximum possible number of nodes in suffix tree
    // number of letters in the alphabet
    ll n, alpha;
    // the node of the current suffix (if we're mid-edge, the lower node of the edge)
    // position in the string which corresponds to the position on the edge (between lo[cur_node] and hi[cur_node], inclusive)
    // the number of nodes
    // the current character in the string
    ll cur_node, cur_pos, cur_sz, cur_ch;
 
    SuffixTree(str &s_in, ll alpha = 27) : s(s_in), alpha(alpha) {
        s += '$';
        n = sz(s) * 2 + 2;
        tree.resize(n, vector<ll>(alpha, -1));
        lo.resize(n), hi.resize(n, sz(s) - 1), par.resize(n), link.resize(n);
        cur_sz = 2, cur_node = 0, cur_pos = 0;
        // initialize data for the ROOT of the tree
        link[0] = 1; lo[0] = hi[0] = lo[1] = hi[1] = -1;
        tree[1] = vector<ll>(alpha, 0);
        // add the text to the tree, letter by letter
        for (cur_ch = 0; cur_ch < sz(s); cur_ch++) add_char(ch_to_idx(s[cur_ch]));
    }
 
    ll ch_to_idx(ch c) {
        if (c == '$') return 26;
        else return c - 'a';
    }
 
    // add character c to the tree
    void add_char(ll c) {
        // we'll return here after each transition to the suffix (and will add character again)
        suff:;
        // check whether we're still within the boundaries of the current edge
        if (hi[cur_node] < cur_pos) {
            // if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree
            if (tree[cur_node][c] == -1) {
                tree[cur_node][c] = cur_sz;
                lo[cur_sz] = cur_ch;
                par[cur_sz++] = cur_node;
                cur_node = link[cur_node];
                cur_pos = hi[cur_node] + 1;
                goto suff;
            }
            cur_node = tree[cur_node][c];
            cur_pos = lo[cur_node];
        } // otherwise just proceed to the next edge
        // if the letter on the edge equal c, go down that edge
        if (cur_pos == -1 || c == ch_to_idx(s[cur_pos])) cur_pos++;
        else { 
            // otherwise split the edge in two with middle in node cur_sz
            lo[cur_sz] = lo[cur_node];
            hi[cur_sz] = cur_pos - 1;
            par[cur_sz] = par[cur_node];
            tree[cur_sz][ch_to_idx(s[cur_pos])] = cur_node;
            // add leaf cur_sz+1. It corresponds to transition through c.
            tree[cur_sz][c] = cur_sz + 1;
            lo[cur_sz + 1] = cur_ch;
            par[cur_sz + 1] = cur_sz;
            // update info for the current node - remember to mark cur_sz as parent of cur_node
            lo[cur_node] = cur_pos;
            par[cur_node] = cur_sz;
            tree[par[cur_sz]][ch_to_idx(s[lo[cur_sz]])] = cur_sz;
            cur_sz += 2;
            // prepare for descent
            // cur_pos will mark where are we in the current suffix
            cur_node = link[par[cur_sz - 2]];
            cur_pos = lo[cur_sz - 2];
            // while the current suffix is not over, descend
            while (cur_pos <= hi[cur_sz - 2]) {
                cur_node = tree[cur_node][ch_to_idx(s[cur_pos])];
                cur_pos += hi[cur_node] - lo[cur_node] + 1;
            }
            // if we're in a node, add a suffix link to it, otherwise add the link to cur_sz
            // (we'll create cur_sz on next iteration).
            if (cur_pos == hi[cur_sz - 2] + 1) link[cur_sz - 2] = cur_node;
            else link[cur_sz - 2] = cur_sz;
            // add cur_pos to the new edge and return to add letter to suffix
            cur_pos = hi[cur_node] - (cur_pos - hi[cur_sz - 2]) + 2;
            goto suff;
        }
    }

    void print() {
        FOR (i, cur_sz) {
            cout << i << ": [" << lo[i] << ", " << hi[i] << "] par: " << par[i] << " link: " << link[i] << '\n';
            FOR (j, alpha) {
                if (tree[i][j] != -1) {
                    if (j == 0) cout << "$ ";
                    else cout << (ch) ('a' + j - 1) << ' ';
                    cout << tree[i][j] << '\n';
                }
            }
        }
    }
};

ll gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth, ll v = 0, ll d = 0) {
    depth[v] = d;
    ll rv = 0;
    FOR (i, st.alpha) {
        if (st.tree[v][i] != -1) {
            rv += gen_tree(st, leafs, depth, st.tree[v][i], d + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1);
        }
    }
    if (rv == 0) rv = 1;
    leafs[v] = rv;
    return rv;
}

void gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth) {
    vector<ll> in(st.cur_size);
    queue<ll> depth_q, leaf_q;
    depth_q.push(0);
    while (!depth_q.empty()) {
        ll v = depth_q.front();
        depth_q.pop();
        bool is_leaf = true;
        FOR (i, st.alpha) {
            if (st.tree[v][i] != -1) {
                depth[st.tree[v][i]] = depth[v] + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1;
                depth_q.push(st.tree[v][i]);
                in[v]++;
                is_leaf = false;
            }
        }
        if (is_leaf) {
            leafs[v] = 1;
            leaf_q.push(v);
        }
    }
    while (!leaf_q.empty()) {
        ll v = leaf_q.front();
        leaf_q.pop();
        if (v != 0) {
            leafs[st.par[v]] += leafs[v];
            in[st.par[v]]--;
            if (in[st.par[v]] == 0) {
                leaf_q.push(st.par[v]);
            }
        }
    }
}

bool dfs(ll u, SuffixTree &st, str &s, str &rv, ll &n) {
    ll lo = 0, hi = -1;
    if (u) {
        lo = st.lo[u];
        hi = min(min(st.hi[u], sz(s) - 1), lo + n - 1);
    }
    n -= hi - lo + 1;
    if (n == 0) {
        rv = s.substr(lo, hi - lo + 1);
        return true;
    }
    FOR (i, 26) {
        ll &v = st.tree[u][i];
        if (v != -1 && dfs(v, st, s, rv, n)) {
            rv = s.substr(lo, hi - lo + 1) + rv;
            return true;
        }
    }
    return false;
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    str s;
    cin >> s;
    SuffixTree st(s);
    vector<int> leafs(st.cur_size), depth(st.cur_size);
    gen_tree(st, leafs, depth);
    int k;
    cin >> k;

    while (k--) {
        str t;
        cin >> t;

        int i = 0, v = 0;
        if (st.tree[0][st.char_to_index(t[0])] == -1) {
            cout << 0 << '\n';
            continue;
        } else v = st.tree[0][st.char_to_index(t[0])];

        bool ok = true;
        int idx = 0;
        while (i < sz(t)) {
            int j = st.lo[v];
            while (j <= st.hi[v] && i < sz(t) && t[i] == s[j]) {
                i++;
                j++;
            }
            if (i == sz(t)) {
                idx = j - sz(t) + 1;
                break;
            }
            if (j > st.hi[v]) {
                if (st.tree[v][st.char_to_index(t[i])] == -1) {
                    ok = false;
                    break;
                } else v = st.tree[v][st.char_to_index(t[i])];
            } else {
                ok = false;
                break;
            }
        }
    }

    return 0;
}

//--------------------------------------------------

vector<bool> vis(n); // Tarjan's Bridge Finding
vector<ll> tin(n), low(n);
ll timer = 0;
bool ok = true; // ok = false if bridge found
auto dfs = [&](auto &&self, ll u, ll p) -> void {
    vis[u] = true;
    tin[u] = low[u] = timer++;
    ll children = 1;
    FORE (v, adj[u]) {
        if (v == p) continue;
        if (vis[v]) low[u] = min(low[u], tin[v]);
        else {
            self(self, v, u);
            low[u] = min(low[u], low[v]);
            if (low[v] > tin[u]) { ok = false; }
            // if (low[v] >= tin[u] && p != -1) {} means u is an articulation point
            children++;
        }
        if (!ok) return;
    }
    // p == -1 && children > 1; ALSO means u is an articulation point
};

//--------------------------------------------------

vector<ll> top_sort(vector<vector<ll>> &adj, vector<ll> &deg) { // deg is in-degree
    ll n = sz(adj);
    vector<ll> ord; queue<ll> q;
    for (ll i = 0; i < n; i++)
        if (deg[i] == 0) q.push(i);
    while (!q.empty()) {
        ll u = q.front(); q.pop();
        ord.pb(u);
        for (ll v : adj[u])
            if (--deg[v] == 0) q.push(v);
    }
    return ord;
}

//--------------------------------------------------

struct Node {
    ll label, priority, size = 1, sum;
    bool rev = false;
    Node *child[2];
    Node(ll label) : label(label), priority(rng()), sum(label) {
        child[0] = child[1] = nullptr;
    }
};

struct Treap {
    Node *ROOT = nullptr;

    ll cnt(Node *node) { return node ? node->size : 0; }

    void upd_cnt(Node *node)
    { if (node) node->size = cnt(node->child[0]) + cnt(node->child[1]) + 1; }

    ll sum(Node *node) { return node ? node->sum : 0; }

    void upd_sum(Node *node)
    { if (node) node->sum = sum(node->child[0]) + sum(node->child[1]) + node->label; }

    void push(Node *node) { // lazy propagation
        if (node && node->rev) {
            node->rev = false;
            swap(node->child[0], node->child[1]);
            if (node->child[0]) node->child[0]->rev ^= true;
            if (node->child[1]) node->child[1]->rev ^= true;
        }
    }

    void merge(Node *&node, Node *l, Node *r) { // merges l and r into node
        push(l), push(r);
        if (!l || !r) node = l ? l : r;
        elif (l->priority > r->priority) merge(l->child[1], l->child[1], r), node = l;
        else merge(r->child[0], l, r->child[0]), node = r;
        upd_cnt(node);
        upd_sum(node);
    }

    void split(Node *node, Node *&l, Node *&r, ll key, ll add = 0) { // splits node into l and r
        if (!node) return void(l = r = nullptr);
        push(node);
        ll cur_key = add + cnt(node->child[0]);
        if (key <= cur_key) split(node->child[0], l, node->child[0], key, add), r = node;
        else split(node->child[1], node->child[1], r, key, add + 1 + cnt(node->child[0])), l = node;
        upd_cnt(node);
        upd_sum(node);
    }

    void reverse(Node *node, ll l, ll r) { // reverses [l, r]
        Node *t1, *t2, *t3;
        split(node, t1, t2, l);
        split(t2, t2, t3, r - l + 1);
        t2->rev ^= true;
        merge(node, t1, t2);
        merge(node, node, t3);
    }

    void output(Node *node) { // inorder traversal
        if (!node) return;
        push(node);
        output(node->child[0]);
        cout << node->label;
        output(node->child[1]);
    }
};

//--------------------------------------------------

void make_clockwise(vector<pld> &points) {
    pld center = mp(0, 0);
    FORE (p, points) {
        center.x += p.x;
        center.y += p.y;
    }
    center.x /= sz(points);
    center.y /= sz(points);
    sort(all(points), [center](pld &p1, pld &p2) {
        return atan2(p1.y - center.y, p1.x - center.x) <
               atan2(p2.y - center.y, p2.x - center.x);
    });
}

bool in_triangle(pld &point, vector<pld> &triangle) {
    vector<ld> d(3);
    FOR (i, 3) {
        auto &p1 = triangle[i];
        auto &p2 = triangle[(i + 1) % 3];
        d[i] = (p2.x - p1.x) * (point.y - p1.y) -
            (p2.y - p1.y) * (point.x - p1.x);
    }
    return (d[0] >= 0 && d[1] >= 0 && d[2] >= 0) || (d[0] <= 0 && d[1] <= 0 && d[2] <= 0);
}

//--------------------------------------------------

constexpr ll ALPHA = 26;

struct Trie {
    ch c;
    bool ending = false;
    vector<Trie*> children = vector<Trie*>(ALPHA, nullptr);

    Trie(ch c_) : c(c_) {}

    void insert(ll i, str &s) {
        if (i == sz(s)) {
            ending = true;
            return;
        }
        ll si = s[i] - 'a';
        if (children[si] == nullptr) {
            children[si] = new Trie(s[i]);
        }
        children[si]->insert(i + 1, s);
    }
};

//--------------------------------------------------

struct TwoSat {
    ll n; vector<vector<ll>> qr;
    vector<ll> values; // 0: false, 1: true (only holds if solve() returns true)
    vector<ll> val, comp, z; ll time = 0;
    TwoSat(ll n) : n(n), qr(2 * n) {}
    void either(ll f, ll j) { // ts.either(0, ~3) 0 is true or 3 is false
        f = max(2 * f, -1 - 2 * f);
        j = max(2 * j, -1 - 2 * j);
        qr[f].pb(j ^ 1);
        qr[j].pb(f ^ 1);
    }
    void set_value(ll x) { either(x, x); } // ts.set_value(2) 2 is true
    void at_most_one(const vector<ll>& li) { // ts.at_most_one({0, ~1, 2}) <= 1 of 0, ~1, 2 is true
        if (sz(li) < 2) return;
        ll cur = ~li[0];
        for (ll i = 2; i < sz(li); i++) {
            ll next = li[i];
            ll v = n++;
            either(cur, ~v);
            either(next, ~v);
            cur = ~v;
        }
        either(cur, ~li[1]);
    }
    ll dfs(ll i) {
        ll low = val[i] = ++time, x; z.pb(i);
        for (ll j : qr[i]) if (!comp[j]) low = min(low, val[j] ?: dfs(j));
        if (low == val[i]) do {
            x = z.back(); z.pop_back();
            comp[x] = low;
            if (values[x >> 1] == -1) values[x >> 1] = x & 1;
        } while (x != i);
        return val[i] = low;
    }
    bool solve() {
        values.assign(n, -1); val.assign(2 * n, 0); comp = val;
        FOR (i, 2 * n) if (!comp[i]) dfs(i);
        FOR (i, n) if (comp[2 * i] == comp[2 * i + 1]) return 0;
        return 1;
    }
};

//--------------------------------------------------

pld extend(pld p0, pld p1, ld r) { // extend p1 from p0 by r
    ld dx = p1.x - p0.x, dy = p1.y - p0.y;
    ld d = sqrt(dx * dx + dy * dy);
    dx /= d, dy /= d;
    return {p1.x + dx * r, p1.y + dy * r};
}

ld angle(pld p0, pld p1, pld p2) { // angle between vec p0p1 and p0p2
    pld w = {p1.x - p0.x, p1.y - p0.y},
        v = {p2.x - p0.x, p2.y - p0.y};
    return atan2(
        w.y * v.x - w.x * v.y,
        w.x * v.x + w.y * v.y
    );
}

pld proj(pld p0, pld p1, pld p2) { // proj p2 onto p0p1
    pld w = {p1.x - p0.x, p1.y - p0.y},
        v = {p2.x - p0.x, p2.y - p0.y};
    ld d = sqrt(w.x * w.x + w.y * w.y);
    w.x /= d, w.y /= d;
    return {p0.x + w.x * (w.x * v.x + w.y * v.y), p0.y + w.y * (w.x * v.x + w.y * v.y)};
}

//--------------------------------------------------

// f(x) = w0 + sum_(p in V) wp(xp) + sum_(p, q in E) wpq(xp, xq)
// in binary variables xp in {0, 1} for p in V and E = V x V
// if wpq(0, 0) + wpq(1, 1) <= wpq(0, 1) + wpq(1, 0) for all p, q in E, then
// we can use graph cut optimization

// https://en.wikipedia.org/wiki/Quadratic_pseudo-Boolean_optimization

//--------------------------------------------------

// if moving +1 with probability p, probability to reach N before 0 from k is:
// if p=0.5:    P(k) = k / N
// else:        q := 1 - p, P(k) = (1 - (q / p)^k) / (1 - (q / p)^N)

//--------------------------------------------------

#include <iostream>
#include <set>

// Custom comparator function
bool customCompare(int a, int b) {
    // Example: Sort in descending order
    return a > b;
}

int main() {
    // Create a set with custom comparator function
    std::set<int, decltype(&customCompare)> mySet(customCompare);

    mySet.insert({3, 1, 4, 1, 5, 9, 2, 6});

    // Print elements of the set
    for (const int& elem : mySet) {
        std::cout << elem << " ";  // Output: 9 6 5 4 3 2 1
    }

    return 0;
}