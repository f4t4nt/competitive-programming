#include <bits/stdc++.h>
#include <bits/extc++.h>

using namespace std;
using namespace __gnu_pbds;

using ll = long long;
using ld = long double;
using ch = char;
using str = string;
using ost = tree<str, null_type, less<str>, rb_tree_tag, tree_order_statistics_node_update>;

#define pb push_back
#define elif else if
#define sz(C) (ll) C.size()
#define all(C) C.begin(), C.end()
#define flip(C) reverse(all(C))
#define ssort(C) sort(all(C))
#define rsort(C) sort(all(C), greater<>())

#define FOR(x, e) for(ll x = 0; x < (ll) e; x++)
#define FORR(x, e) for(ll x = (ll) e - 1; x >= 0; x--)
#define FOB(x, b, e) for(auto x = b; x < e; x++)
#define FORE(x, C) for(auto &x : C)

// Run -> Add configuration... -> in launch.json:
// "program": "${fileDirname}/${fileBasenameNoExtension}",
// "preLaunchTask": "C/C++: g++ build active file",

//--------------------------------------------------

// clockwise angle from (x1, y1) to (x0, y0) to (x2, y2)
ld angle(ld x1, ld y1, ld x0, ld y0, ld x2, ld y2) {
    ld dot = (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0),
        det = (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0),
        rv = atan2(det, dot);
    if (rv < 0) {
        rv += 2 * M_PI;
    }
    return rv;
}

//--------------------------------------------------

ll bin_search_find_last(vector<ll> &a) {
        ll lo = 0, hi = sz(a) - 1;
        while (lo < hi) {
            ll mid = (lo + hi + 1) / 2;
            if (valid(mid)) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
}

ll bin_search_find_first(vector<ll> &a) {
    ll lo = 0, hi = sz(a) - 1;
    while (lo < hi) {
        ll mid = (lo + hi) / 2;
        if (valid(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
}

//--------------------------------------------------

ll bitcount(ll x) {
    ll rv = 0;
    while(x > 0) {
        rv++;
        x &= (x - 1);
    }
    return rv;
}

//--------------------------------------------------

struct BIT {
    vector<ll> tree;
    ll n;

    BIT(ll n) : n(n) {
        tree.resize(n + 1);
    }

    void update(ll idx, ll val) {
        idx++;
        while (idx <= n) {
            tree[idx] += val;
            idx += idx & (-idx);
        }
    }

    ll query(ll idx) {
        idx++;
        ll sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= idx & (-idx);
        }
        return sum;
    }

    ll query(ll l, ll r) {
        return query(r) - query(l - 1);
    }
};

//--------------------------------------------------

pair<ld, ld> get_com(vector<pair<ld, ld>> &poly) {
    ld x = 0, y = 0;
    ld area = 0;
    FOR (i, sz(poly)) {
        ll j = (i + 1) % sz(poly);
        ld a = poly[i].first * poly[j].second - poly[j].first * poly[i].second;
        area += a;
        x += (poly[i].first + poly[j].first) * a;
        y += (poly[i].second + poly[j].second) * a;
    }
    area /= 2;
    x /= 6 * area;
    y /= 6 * area;
    return {x, y};
}

//--------------------------------------------------

vector<pair<ld, ld>> convex_hull(vector<pair<ld, ld>> points) {
    // sort points by x-coordinate
    ssort(points);

    // lower hull
    vector<pair<ld, ld>> lower;
    for (auto &p : points) {
        while (sz(lower) >= 2) {
            auto &p1 = lower[sz(lower) - 2];
            auto &p2 = lower[sz(lower) - 1];
            if ((p2.second - p1.second) * (p.first - p2.first) >= (p.second - p2.second) * (p2.first - p1.first)) {
                lower.pop_back();
            } else {
                break;
            }
        }
        lower.pb(p);
    }

    // upper hull
    vector<pair<ld, ld>> upper;
    for (auto it = points.rbegin(); it != points.rend(); it++) {
        auto &p = *it;
        while (sz(upper) >= 2) {
            auto &p1 = upper[sz(upper) - 2];
            auto &p2 = upper[sz(upper) - 1];
            if ((p2.second - p1.second) * (p.first - p2.first) >= (p.second - p2.second) * (p2.first - p1.first)) {
                upper.pop_back();
            } else {
                break;
            }
        }
        upper.pb(p);
    }

    // remove duplicates
    lower.pop_back();
    upper.pop_back();

    // merge lower and upper hulls
    lower.insert(lower.end(), upper.begin(), upper.end());
    return lower;
}

//--------------------------------------------------

void customsort() {
    vector<ll> x;
    sort(x.begin(), x.end(),
        &[] (const ll &a, const ll &b) -> bool
        { return a < b; });
    // equivalent to regular sort
}

//--------------------------------------------------

vector<ll> dist(n, INF);
dist[0] = 0;
priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<>> pq;
pq.push({0, 0});
while (!pq.empty()) {
    ll cur_d, u;
    tie(cur_d, u) = pq.top();
    pq.pop();
    if (cur_d > dist[u]) {
        continue;
    }
    FORE (elem, adj_s[u]) {
        ll v, w;
        tie(v, w) = elem;
        if (dist[v] > dist[u] + w) {
            dist[v] = dist[u] + w;
            pq.push({dist[v], v});
        }
    }
}

//--------------------------------------------------

struct Dinic {
    struct Edge {
        ll from, to, cap, flow = 0;
        Edge(ll from, ll to, ll cap) : from(from), to(to), cap(cap) {}
    };

    ll n, m = 0;
    vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> level, ptr;
    queue<ll> q;

    Dinic(ll n) : n(n) {
        adj.resize(n);
        level.resize(n);
        ptr.resize(n);
    }

    Dinic(vector<vector<pair<ll, ll>>> adj) {
        n = sz(adj);
        this->adj.resize(n);
        level.resize(n);
        ptr.resize(n);
        FOR (i, n) {
            FORE (e, adj[i]) {
                add_edge(i, e.first, e.second);
            }
        }
    }

    void add_edge(ll from, ll to, ll cap) {
        edges.pb({from, to, cap});
        edges.pb({to, from, 0});
        adj[from].pb(m);
        adj[to].pb(m + 1);
        m += 2;
    }

    bool bfs(ll s, ll t) {
        while (!q.empty()) {
            ll v = q.front();
            q.pop();
            for (ll id : adj[v]) {
                if (edges[id].cap - edges[id].flow < 1) {
                    continue;
                }
                if (level[edges[id].to] != -1) {
                    continue;
                }
                level[edges[id].to] = level[v] + 1;
                q.push(edges[id].to);
            }
        }
        return level[t] != -1;
    }

    ll dfs(ll v, ll t, ll pushed) {
        if (pushed == 0) {
            return 0;
        }
        if (v == t) {
            return pushed;
        }
        for (ll &cid = ptr[v]; cid < (ll) adj[v].size(); cid++) {
            ll id = adj[v][cid];
            ll u = edges[id].to;
            if (level[v] + 1 != level[u] || edges[id].cap - edges[id].flow < 1) {
                continue;
            }
            ll tr = dfs(u, t, min(pushed, edges[id].cap - edges[id].flow));
            if (tr == 0) {
                continue;
            }
            edges[id].flow += tr;
            edges[id ^ 1].flow -= tr;
            return tr;
        }
        return 0;
    }

    ll max_flow(ll s, ll t) {
        ll flow = 0;
        while (true) {
            fill(level.begin(), level.end(), -1);
            level[s] = 0;
            q.push(s);
            if (!bfs(s, t)) {
                break;
            }
            fill(ptr.begin(), ptr.end(), 0);
            while (ll pushed = dfs(s, t, LLONG_MAX)) {
                flow += pushed;
            }
        }
        return flow;
    }
    
    vector<pair<ll, ll>> min_cut(ll s) {
        bfs(s, -1);
        vector<pair<ll, ll>> cut;
        FOR (i, m) {
            if (level[edges[i].from] != -1 && level[edges[i].to] == -1 && edges[i].cap) {
                cut.pb({edges[i].from, edges[i].to});
            }
        }
        return cut;
    }
};

//--------------------------------------------------

struct DSU {
    ll cnt;
    vector<ll> e;
    DSU(ll n) { e = vector<ll>(n, -1); cnt = n; }
    void reset() { e = vector<ll>(sz(e), -1); cnt = sz(e); }
    ll get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
    bool same_set(ll a, ll b) { return get(a) == get(b); }
    ll size(ll x) { return -e[get(x)]; }
    ll count() { return cnt; }
    bool unite(ll x, ll y) {
        x = get(x), y = get(y);
        if (x == y) return false;
        if (e[x] > e[y]) swap(x, y);
        e[x] += e[y]; e[y] = x;
        cnt--;
        return true;
    }
};

//--------------------------------------------------

constexpr ll MOD = 1e9 + 7;
constexpr ll MAX_N = 1e3;

ll fact[MAX_N + 1];
ll inv_fact[MAX_N + 1];
ll inv[MAX_N + 1];
ll choose[MAX_N + 1][MAX_N + 1];
ll perm[MAX_N + 1][MAX_N + 1];

void init() {
    fact[0] = 1;
    inv_fact[0] = 1;
    inv[1] = 1;
    for (ll i = 1; i <= MAX_N; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
        if (i > 1) {
            inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;
        }
        inv_fact[i] = (inv_fact[i - 1] * inv[i]) % MOD;
    }
    for (ll i = 0; i <= MAX_N; i++) {
        for (ll j = 0; j <= i; j++) {
            choose[i][j] = (fact[i] * inv_fact[j] % MOD) * inv_fact[i - j] % MOD;
        }
    }
    for (ll i = 0; i <= MAX_N; i++) {
        for (ll j = 0; j <= i; j++) {
            perm[i][j] = (fact[i] * inv_fact[i - j]) % MOD;
        }
    }
}

//--------------------------------------------------

void floyd_warshall(vector<vector<ll>> &dist) {
    ll n = sz(dist);
    FOR (k, n) {
        FOR (i, n) {
            FOR (j, n) {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
}

void bellman_ford(ll v, vector<tuple<ll, ll, ll>> &edges, vector<ll> &dist) {
    ll n = sz(dist);
    FOR (i, n) {
        dist[i] = INF;
    }
    dist[v] = 0;
    FOR (i, n - 1) {
        for (auto [a, b, w] : edges) {
            if (dist[a] != INF && dist[a] + w < dist[b]) {
                dist[b] = dist[a] + w;
            }
        }
    }
}

//--------------------------------------------------

bool game(auto state, bool alice) {
    if (mem.find(state) != mem.end()) {
        return mem[state];
    }
    FORE (move, all_moves) {
        if (valid(move)) {
            change_state();
            if (!game(state, !alice)) {
                restore_state();
                mem[state] = true;
                return true;
            }
            restore_state();
        }
    }
    mem[state] = false;
    return false;
}

//--------------------------------------------------

ll gauss_jordan(vector<vector<ld>> &A, vector<ld> &b, vector<ld> &x) {
    ll n = A.size(), m = A[0].size();
    vector<vector<ld>> a(n, vector<ld>(m + 1));
    FOR(i, n) {
        FOR(j, m) {
            a[i][j] = A[i][j];
        }
        a[i][m] = b[i];
    }
    vector<ll> where(m, -1);
    for (ll col = 0, row = 0; col < m && row < n; col++) {
        ll sel = row;
        FOB (i, row, n) {
            if (abs(a[i][col]) > abs(a[sel][col])) {
                sel = i;
            }
        }
        if (abs(a[sel][col]) < EPS) {
            continue;
        }
        FOB (i, col, m + 1) {
            swap(a[sel][i], a[row][i]);
        }
        where[col] = row;
        FOR (i, n) {
            if (i != row) {
                ld c = a[i][col] / a[row][col];
                FOB (j, col, m + 1) {
                    a[i][j] -= a[row][j] * c;
                }
            }
        }
        row++;
    }
    x.assign(m, 0);
    FOR (i, m) {
        if (where[i] != -1) {
            x[i] = a[where[i]][m] / a[where[i]][i];
        }
    }
    FOR (i, n) {
        ld sum = 0;
        FOR (j, m) {
            sum += a[i][j] * x[j];
        }
        if (abs(sum - a[i][m]) > EPS) { // may need to change for modulo
            return 0;
        }
    }
    FOR (i, m) {
        if (where[i] == -1) {
            return INF;
        }
    }
    return 1;
}

int gauss_jordan_binary(
    vector<bitset<MAXN>> A,
    bitset<MAXN> &b,
    bitset<MAXN> &x,
    int n,
    int m
) {
    FOR (i, n) A[i][m] = b[i];
    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; col++) {
        FOB (i, row, n) {
            if (A[i][col] != 0) {
                swap(A[i], A[row]);
                break;
            }
        }
        if (A[row][col] == 0) continue;
        where[col] = row;
        FOR (i, n) {
            if (i != row && A[i][col] != 0) {
                A[i] ^= A[row];
            }
        }
        row++;
    }
    x = bitset<MAXN>(0);
    ...
}

//--------------------------------------------------

ll gcd(ll a, ll b) {
    if (a == 0) return b;
    return gcd(b % a, a);
}

// a * x + b * y = gcd(a, b)

pair<ll, ll> bezout(ll a, ll b) {
    if (a == 0) return {0, 1};
    auto [x, y] = bezout(b % a, a);
    return {y - (b / a) * x, x};
}

// x % m == a, x % n == b
// x % lcm(m, n) = -(a * v * n + b * u * m) / gcd(m, n)

ll crt(ll m, ll n, ll a, ll b) {
    ll g = gcd(m, n);
    if (a % g != b % g) return -1;
    ll lcm = m * n / g;
    auto [u, v] = bezout(m / g, n / g);
    ll k = (b - a) / g;
    ll x = (a + m * k * u) % lcm;
    if (x < 0) x += lcm;
    return x;
}

//--------------------------------------------------

struct LCA_Tree {
    vector<vector<ll>> parent, adj;
    vector<ll> pre, post, depth;
    ll n, timer;

    LCA_Tree(ll &n0, vector<vector<ll>> &adj0) {
        n = n0;
        timer = 0;
        pre = vector<ll>(n), post = pre, depth = pre;
        parent = vector<vector<ll>>(n, vector<ll>(30));
        adj = adj0;
        dfs(0, 0, 0);
        gen();
    }

    void dfs(ll node, ll par, ll d) {
        pre[node] = timer++;
        depth[node] = d;
        parent[node][0] = par;
        FORE (child, adj[node]) {
            if (child != par) {
                dfs(child, node, d + 1);
            }
        }
        post[node] = timer++;
    }

    void gen() {
        FOR (i, 29) {
            FOR (j, n) {
                parent[j][i + 1] = parent[parent[j][i]][i];
            }
        }
    }

    bool is_anc(ll u, ll v) {
        return pre[u] <= pre[v] && post[u] >= post[v];
    }

    ll lca(ll u, ll v) {
        if (is_anc(u, v)) return u;
        if (is_anc(v, u)) return v;
        FORR (i, 30) {
            if (!is_anc(parent[u][i], v)) {
                u = parent[u][i];
            }
        }
        return parent[u][0];
    }

    ll dist(ll u, ll v) {
        return depth[u] + depth[v] - 2 * depth[lca(u, v)];
    }

    bool disjoint(vector<pair<ll, ll>> paths) {
        vector<pair<ll, ll>> p;
        FORE (path, paths) {
            ll u, v;
            tie(u, v) = path;
            ll w = lca(u, v);
            p.pb({w, u});
            p.pb({w, v});
        }
        FOR (i, sz(p)) {
            FOR (j, i - i % 2) {
                if (!(lca(p[i].second, p[j].first) != p[j].first ||
                    lca(p[j].second, p[i].first) != p[i].first))
                {
                    return false;
                }
            }
        }
        return true;
    }
};

//--------------------------------------------------

pair<ll, ll> manacher(str &s) {
    str t = "$#";
    FORE (c, s) {
        t += c;
        t += '#';
    }

    ll n = sz(t);
    ll center = 0, max_rad = -1, rad;
    vector<ll> p(n);
    FOR (i, n) {
        if (i <= max_rad) {
            rad = min(p[2 * center - i], max_rad - i);
        } else {
            rad = 0;
        }
        while (i - rad - 1 >= 0 && i + rad + 1 < n && t[i - rad - 1] == t[i + rad + 1]) {
            rad++;
        }
        p[i] = rad;
        if (i + rad > max_rad) {
            center = i;
            max_rad = i + rad;
        }
    }

    ll len = 0, idx = 0;
    FOR (i, n) {
        if (p[i] > len) {
            len = p[i];
            idx = i;
        }
    }

    return {len, (idx - len) / 2};
}

//--------------------------------------------------

ll mask(ll x) {
    ll rv = x;
    while (rv & (rv + 1)) {
        rv |= rv / 2;
    }
    return rv;
}

//--------------------------------------------------

struct Edge {
    ll s, t, cap, cost;
    Edge (ll s, ll t, ll cap, ll cost) : s(s), t(t), cap(cap), cost(cost) {}
};

struct Flow {
    ll n;
    vector<vector<ll>> adj, cap, cost;

    Flow(ll n, vector<Edge> &edges) : n(n), adj(n), cap(n, vector<ll>(n)), cost(n, vector<ll>(n)) {
        FORE (e, edges) {
            adj[e.s].pb(e.t);
            adj[e.t].pb(e.s);
            cap[e.s][e.t] = e.cap;
            cap[e.t][e.s] = 0;
            cost[e.s][e.t] = e.cost;
        }
    }

    ll bfs(ll s, ll t, vector<ll>& par) {
        fill(all(par), -1);
        par[s] = -2;
        queue<pair<ll, ll>> q;
        q.push({s, INF});
        while (!q.empty()) {
            ll cur = q.front().first;
            ll flow = q.front().second;
            q.pop();
            FORE (next, adj[cur]) {
                if (par[next] == -1 && cap[cur][next]) {
                    par[next] = cur;
                    ll new_flow = min(flow, cap[cur][next]);
                    if (next == t)
                        return new_flow;
                    q.push({next, new_flow});
                }
            }
        }

        return 0;
    }

    ll max_flow(ll s, ll t) {
        auto cap_copy = cap;
        ll flow = 0;
        vector<ll> par(n);
        ll new_flow;
        while (true) {
            new_flow = bfs(s, t, par);
            if (!new_flow) {
                break;
            }
            flow += new_flow;
            ll cur = t;
            while (cur != s) {
                ll prev = par[cur];
                cap[prev][cur] -= new_flow;
                cap[cur][prev] += new_flow;
                cur = prev;
            }
        }
        cap = cap_copy;
        return flow;
    }

    void shortest_paths(ll n, ll v0, vector<ll>& d, vector<ll>& p) {
        d.assign(n, INF);
        d[v0] = 0;
        vector<bool> inq(n, false);
        queue<ll> q;
        q.push(v0);
        p.assign(n, -1);

        while (!q.empty()) {
            ll u = q.front();
            q.pop();
            inq[u] = false;
            FORE (v, adj[u]) {
                if (cap[u][v] > 0 && d[v] > d[u] + cost[u][v]) {
                    d[v] = d[u] + cost[u][v];
                    p[v] = u;
                    if (!inq[v]) {
                        inq[v] = true;
                        q.push(v);
                    }
                }
            }
        }
    }

    ll min_cost_flow(ll s, ll t, ll k) {
        auto cap_copy = cap;
        ll flow = 0;
        ll cost = 0;
        vector<ll> d, p;
        while (flow < k) {
            shortest_paths(n, s, d, p);
            if (d[t] == INF) {
                break;
            }
            ll f = k - flow;
            ll cur = t;
            while (cur != s) {
                f = min(f, cap[p[cur]][cur]);
                cur = p[cur];
            }
            flow += f;
            cost += f * d[t];
            cur = t;
            while (cur != s) {
                cap[p[cur]][cur] -= f;
                cap[cur][p[cur]] += f;
                cur = p[cur];
            }
        }
        cap = cap_copy;
        if (flow < k) {
            return -1;
        } else {
            return cost;
        }
    }

    void dfs(ll u, vector<bool> &vis) {
        vis[u] = true;
        FORE (v, adj[u]) {
            if (!vis[v] && cap[u][v]) {
                dfs(v, vis);
            }
        }
    }

    vector<pair<ll, ll>> min_cut(ll s) {
        vector<bool> vis(n);
        vector<pair<ll, ll>> rv;
        dfs(s, vis);
        FOR (u, n) {
            if (vis[u]) {
                FORE (v, adj[u]) {
                    if (!vis[v]) {
                        rv.pb({u, v});
                    }
                }
            }
        }
        return rv;
    }
};

//--------------------------------------------------

ll pow(ll x, ll p) {
    ll rv = 1;
    while(p) {
        if(p & 1) rv *= x;
        x *= x;
        p >>= 1;
    }
    return rv;
}

//--------------------------------------------------

vector<vector<ll>> scc(vector<vector<ll>> adj) {
    ll n = sz(adj);
    vector<ll> order;
    vector<bool> vis(n);
    function<void(ll)> dfs = [&](ll u) {
        vis[u] = true;
        FORE(v, adj[u]) {
            if (!vis[v]) {
                dfs(v);
            }
        }
        order.pb(u);
    };
    FOR(i, n) {
        if (!vis[i]) {
            dfs(i);
        }
    }
    vector<vector<ll>> adjt(n);
    FOR(i, n) {
        FORE(j, adj[i]) {
            adjt[j].pb(i);
        }
    }
    vector<vector<ll>> sccs;
    vis.assign(n, false);
    function<void(ll, vector<ll> &)> dfs2 = [&](ll u, vector<ll> &scc) {
        vis[u] = true;
        scc.pb(u);
        FORE(v, adjt[u]) {
            if (!vis[v]) {
                dfs2(v, scc);
            }
        }
    };
    FORR(i, n) {
        if (!vis[order[i]]) {
            vector<ll> scc;
            dfs2(order[i], scc);
            sccs.pb(scc);
        }
    }
    return sccs;
}

//--------------------------------------------------

struct SegTree {
    ll n;
    vector<ll> data, lazy;
    SegTree (ll n) :
        n(n),
        data(4 * n, 0),
        lazy(4 * n, 0) {}
    // [lo, hi)
    void update(ll lo, ll hi, ll val, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) {
            r = n;
        }
        if (lazy[i] != 0) {
            data[i] += (r - l) * lazy[i];
            if (r - l > 1) {
                lazy[2 * i] += lazy[i];
                lazy[2 * i + 1] += lazy[i];
            }
            lazy[i] = 0;
        }
        if (lo <= l && r <= hi) {
            data[i] += (r - l) * val;
            if (r - l > 1) {
                lazy[2 * i] += val;
                lazy[2 * i + 1] += val;
            }
            return;
        }
        if (r <= lo || hi <= l) {
            return;
        }
        ll m = (l + r) / 2;
        update(lo, hi, val, 2 * i, l, m);
        update(lo, hi, val, 2 * i + 1, m, r);
        data[i] = data[2 * i] + data[2 * i + 1];
    }
    ll query(ll lo, ll hi, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) {
            r = n;
        }
        if (lazy[i] != 0) {
            data[i] += (r - l) * lazy[i];
            if (r - l > 1) {
                lazy[2 * i] += lazy[i];
                lazy[2 * i + 1] += lazy[i];
            }
            lazy[i] = 0;
        }
        if (lo <= l && r <= hi) {
            return data[i];
        }
        if (r <= lo || hi <= l) {
            return 0;
        }
        ll m = (l + r) / 2;
        return query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m, r);
    }
};

//--------------------------------------------------

ld shoelace(vector<pair<ld, ld>> &v) {
    ld area = 0;
    FOR (i, sz(v)) {
        area += (v[i].first * v[(i + 1) % sz(v)].second) -
            (v[i].second * v[(i + 1) % sz(v)].first);
    }
    return abs(area) / 2;
}

//--------------------------------------------------

struct SuffixTree {
    str s; // input string for which the suffix tree is being built
    vector<vector<ll>> tree; // array of transitions (state, letter)
    // left... and right boundaries of the substring of s which correspond to incoming edge
    // parent of the node
    // suffix link
    vector<ll> lo, hi, par, link;
    // maximum possible number of nodes in suffix tree
    // number of letters in the alphabet
    ll n, alpha;
    // the node of the current suffix (if we're mid-edge, the lower node of the edge)
    // position in the string which corresponds to the position on the edge (between lo[cur_node] and hi[cur_node], inclusive)
    // the number of nodes
    // the current character in the string
    ll cur_node, cur_pos, cur_size, cur_char;

    SuffixTree(str &s_in, ll alpha = 27) : s(s_in), alpha(alpha) {
        s += '$';
        n = sz(s) * 2 + 2;
        tree = vector<vector<ll>>(n, vector<ll>(alpha, -1));
        lo = vector<ll>(n);
        hi = vector<ll>(n, sz(s) - 1);
        par = vector<ll>(n);
        link = vector<ll>(n);
        cur_size = 2;
        cur_node = 0;
        cur_pos = 0;
        // initialize data for the root of the tree
        link[0] = 1;
        lo[0] = -1;
        hi[0] = -1;
        lo[1] = -1;
        hi[1] = -1;
        tree[1] = vector<ll>(alpha, 0);
        // add the text to the tree, letter by letter
        for (cur_char = 0; cur_char < sz(s); ++cur_char) {
            add_char(char_to_index(s[cur_char]));
        }
    }

    ll char_to_index(ch c) {
        if (c == '$') {
            return 0;
        } else {
            return c - 'a' + 1;
        }
    }

    // add character c to the tree
    void add_char(ll c) {
        // we'll return here after each transition to the suffix (and will add character again)
        suff:;
        // check whether we're still within the boundaries of the current edge
        if (hi[cur_node] < cur_pos) {
            // if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree
            if (tree[cur_node][c] == -1) {
                tree[cur_node][c] = cur_size;
                lo[cur_size] = cur_char;
                par[cur_size++] = cur_node;
                cur_node = link[cur_node];
                cur_pos = hi[cur_node] + 1;
                goto suff;
            }
            cur_node = tree[cur_node][c];
            cur_pos = lo[cur_node];
        } // otherwise just proceed to the next edge
        if (cur_pos == -1 || c == char_to_index(s[cur_pos])) {
            cur_pos++; // if the letter on the edge equal c, go down that edge
        } else { 
            // otherwise split the edge in two with middle in node cur_size
            lo[cur_size] = lo[cur_node];
            hi[cur_size] = cur_pos - 1;
            par[cur_size] = par[cur_node];
            tree[cur_size][char_to_index(s[cur_pos])] = cur_node;
            // add leaf cur_size+1. It corresponds to transition through c.
            tree[cur_size][c] = cur_size + 1;
            lo[cur_size + 1] = cur_char;
            par[cur_size + 1] = cur_size;
            // update info for the current node - remember to mark cur_size as parent of cur_node
            lo[cur_node] = cur_pos;
            par[cur_node] = cur_size;
            tree[par[cur_size]][char_to_index(s[lo[cur_size]])] = cur_size;
            cur_size += 2;
            // prepare for descent
            // cur_pos will mark where are we in the current suffix
            cur_node = link[par[cur_size - 2]];
            cur_pos = lo[cur_size - 2];
            // while the current suffix is not over, descend
            while (cur_pos <= hi[cur_size - 2]) {
                cur_node = tree[cur_node][char_to_index(s[cur_pos])];
                cur_pos += hi[cur_node] - lo[cur_node] + 1;
            }
            // if we're in a node, add a suffix link to it, otherwise add the link to cur_size
            // (we'll create cur_size on next iteration).
            if (cur_pos == hi[cur_size - 2] + 1) {
                link[cur_size - 2] = cur_node;
            } else {
                link[cur_size - 2] = cur_size;
            } 
            // add cur_pos to the new edge and return to add letter to suffix
            cur_pos = hi[cur_node] - (cur_pos - hi[cur_size - 2]) + 2;
            goto suff;
        }
    }

    void print() {
        FOR (i, cur_size) {
            cout << i << ':' << lo[i] << ' ' << hi[i] << ' ' << par[i] << ' ' << link[i] << " " << '\n';
            FOR (j, alpha) {
                if (tree[i][j] != -1) {
                    if (j == 0) {
                        cout << "$ ";
                    } else {
                        cout << (char)('a' + j - 1) << ' ';
                    }
                    cout << tree[i][j] << '\n';
                }
            }
        }
    }
};

ll gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth, ll v = 0, ll d = 0) {
    depth[v] = d;
    ll rv = 0;
    FOR (i, st.alpha) {
        if (st.tree[v][i] != -1) {
            rv += gen_tree(st, leafs, depth, st.tree[v][i], d + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1);
        }
    }
    if (rv == 0) {
        rv = 1;
    }
    leafs[v] = rv;
    return rv;
}

void gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth) {
    vector<ll> in(st.cur_size);
    queue<ll> depth_q, leaf_q;
    depth_q.push(0);
    while (!depth_q.empty()) {
        ll v = depth_q.front();
        depth_q.pop();
        bool is_leaf = true;
        FOR (i, st.alpha) {
            if (st.tree[v][i] != -1) {
                depth[st.tree[v][i]] = depth[v] + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1;
                depth_q.push(st.tree[v][i]);
                in[v]++;
                is_leaf = false;
            }
        }
        if (is_leaf) {
            leafs[v] = 1;
            leaf_q.push(v);
        }
    }
    while (!leaf_q.empty()) {
        ll v = leaf_q.front();
        leaf_q.pop();
        if (v != 0) {
            leafs[st.par[v]] += leafs[v];
            in[st.par[v]]--;
            if (in[st.par[v]] == 0) {
                leaf_q.push(st.par[v]);
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    str s;
    cin >> s;
    SuffixTree st(s);
    vector<int> leafs(st.cur_size), depth(st.cur_size);
    gen_tree(st, leafs, depth);
    int k;
    cin >> k;

    while (k--) {
        str t;
        cin >> t;

        int i = 0, v = 0;
        if (st.tree[0][st.char_to_index(t[0])] == -1) {
            cout << 0 << '\n';
            continue;
        } else {
            v = st.tree[0][st.char_to_index(t[0])];
        }

        bool ok = true;
        int idx = 0;
        while (i < sz(t)) {
            int j = st.lo[v];
            while (j <= st.hi[v] && i < sz(t) && t[i] == s[j]) {
                i++;
                j++;
            }
            if (i == sz(t)) {
                idx = j - sz(t) + 1;
                break;
            }
            if (j > st.hi[v]) {
                if (st.tree[v][st.char_to_index(t[i])] == -1) {
                    ok = false;
                    break;
                } else {
                    v = st.tree[v][st.char_to_index(t[i])];
                }
            } else {
                ok = false;
                break;
            }
        }
    }

    return 0;
}

//--------------------------------------------------

#include <ext/pb_ds/assoc_container.hpp>

using namespace __gnu_pbds;

template<class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

//--------------------------------------------------

void make_clockwise(vector<pair<ld, ld>> &points) {
    pair<ld, ld> center = mp(0, 0);
    FORE (p, points) {
        center.first += p.first;
        center.second += p.second;
    }
    center.first /= sz(points);
    center.second /= sz(points);
    sort(all(points), [center](pair<ld, ld> &p1, pair<ld, ld> &p2) {
        return atan2(p1.second - center.second, p1.first - center.first) <
               atan2(p2.second - center.second, p2.first - center.first);
    });
}

bool in_triangle(pair<ld, ld> &point, vector<pair<ld, ld>> &triangle) {
    vector<ld> d(3);
    FOR (i, 3) {
        auto &p1 = triangle[i];
        auto &p2 = triangle[(i + 1) % 3];
        d[i] = (p2.first - p1.first) * (point.second - p1.second) -
            (p2.second - p1.second) * (point.first - p1.first);
    }
    return (d[0] >= 0 && d[1] >= 0 && d[2] >= 0) || (d[0] <= 0 && d[1] <= 0 && d[2] <= 0);
}

//--------------------------------------------------

constexpr ll ALPHA = 26;

struct Trie {
    ch c;
    bool ending = false;
    vector<Trie*> children = vector<Trie*>(ALPHA, nullptr);

    Trie(ch c_) : c(c_) {}

    void insert(ll i, str &s) {
        if (i == sz(s)) {
            ending = true;
            return;
        }
        ll si = s[i] - 'a';
        if (children[si] == nullptr) {
            children[si] = new Trie(s[i]);
        }
        children[si]->insert(i + 1, s);
    }
};