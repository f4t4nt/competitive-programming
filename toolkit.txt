#include <bits/stdc++.h>

using namespace std;

using ll = long long;
using ull = unsigned long long;
using cd = complex<long double>;
using ld = long double;
using ch = char;
using str = string;

#include <ext/pb_ds/assoc_container.hpp>
using namespace __gnu_pbds;

using indexed_set = tree<
    ll,
    null_type,
    less<ll>,
    rb_tree_tag,
    tree_order_statistics_node_update
>;

#define pb push_back
#define elif else if
#define sz(C) (ll) C.size()
#define all(C) C.begin(), C.end()
#define flip(C) reverse(all(C))
#define ssort(C) sort(all(C))
#define rsort(C) sort(all(C), greater<>())

#define FOR(x, e) for(ll x = 0; x < (ll) e; x++)
#define FORR(x, e) for(ll x = (ll) e - 1; x >= 0; x--)
#define FOB(x, b, e) for(auto x = b; x < e; x++)
#define FORE(x, C) for(auto &x : C)

// Run -> Add configuration... -> in launch.json:
// "program": "${fileDirname}/${fileBasenameNoExtension}",
// "preLaunchTask": "C/C++: g++ build active file",

//--------------------------------------------------

// clockwise angle from (x1, y1) to (x0, y0) to (x2, y2)
ld angle(ld x1, ld y1, ld x0, ld y0, ld x2, ld y2) {
    ld dot = (x1 - x0) * (x2 - x0) + (y1 - y0) * (y2 - y0),
        det = (x1 - x0) * (y2 - y0) - (y1 - y0) * (x2 - x0),
        rv = atan2(det, dot);
    if (rv < 0) {
        rv += 2 * M_PI;
    }
    return rv;
}

//--------------------------------------------------

ll bin_search_find_last(vector<ll> &a) {
        ll lo = 0, hi = sz(a) - 1;
        while (lo < hi) {
            ll mid = (lo + hi + 1) / 2;
            if (valid(mid)) {
                lo = mid;
            } else {
                hi = mid - 1;
            }
        }
}

ll bin_search_find_first(vector<ll> &a) {
    ll lo = 0, hi = sz(a) - 1;
    while (lo < hi) {
        ll mid = (lo + hi) / 2;
        if (valid(mid)) {
            hi = mid;
        } else {
            lo = mid + 1;
        }
    }
}

//--------------------------------------------------

ll bitcount(ll x) {
    ll rv = 0;
    while(x > 0) {
        rv++;
        x &= (x - 1);
    }
    return rv;
}

//--------------------------------------------------

struct BIT {
    vector<ll> tree;
    ll n;

    BIT(ll n) : n(n) {
        tree.resize(n + 1);
    }

    void update(ll idx, ll val) {
        idx++;
        while (idx <= n) {
            tree[idx] += val;
            idx += idx & (-idx);
        }
    }

    ll query(ll idx) {
        idx++;
        ll sum = 0;
        while (idx > 0) {
            sum += tree[idx];
            idx -= idx & (-idx);
        }
        return sum;
    }

    ll query(ll l, ll r) {
        return query(r) - query(l - 1);
    }
};

//--------------------------------------------------

pair<ld, ld> get_com(vector<pair<ld, ld>> &poly) {
    ld x = 0, y = 0;
    ld area = 0;
    FOR (i, sz(poly)) {
        ll j = (i + 1) % sz(poly);
        ld a = poly[i].first * poly[j].second - poly[j].first * poly[i].second;
        area += a;
        x += (poly[i].first + poly[j].first) * a;
        y += (poly[i].second + poly[j].second) * a;
    }
    area /= 2;
    x /= 6 * area;
    y /= 6 * area;
    return {x, y};
}

//--------------------------------------------------

vector<pair<ld, ld>> convex_hull(vector<pair<ld, ld>> pts) {
    ssort(pts); // sort points by x-coordinate
    vector<pair<ld, ld>> lo; // lower hull
    for (auto &p : pts) {
        while (sz(lo) >= 2) {
            auto &p1 = lo[sz(lo) - 2];
            auto &p2 = lo[sz(lo) - 1];
            if ((p2.second - p1.second) * (p.first - p2.first) >= (p.second - p2.second) * (p2.first - p1.first)) {
                lo.pop_back();
            } else {
                break;
            }
        }
        lo.pb(p);
    }
    vector<pair<ld, ld>> hi; // upper hull
    for (auto it = pts.rbegin(); it != pts.rend(); it++) {
        auto &p = *it;
        while (sz(hi) >= 2) {
            auto &p1 = hi[sz(hi) - 2];
            auto &p2 = hi[sz(hi) - 1];
            if ((p2.second - p1.second) * (p.first - p2.first) >= (p.second - p2.second) * (p2.first - p1.first)) {
                hi.pop_back();
            } else {
                break;
            }
        }
        hi.pb(p);
    }
    lo.pop_back(); // remove duplicates
    hi.pop_back();
    lo.insert(lo.end(), hi.begin(), hi.end()); // merge lower and upper hulls
    return lo;
}

//--------------------------------------------------

void customsort() {
    vector<ll> x;
    sort(x.begin(), x.end(),
        &[] (const ll &a, const ll &b) -> bool
        { return a < b; });
    // equivalent to regular sort
}

//--------------------------------------------------

vector<ll> dist(n, INF);
dist[0] = 0;
priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<>> pq;
pq.push({0, 0});
while (!pq.empty()) {
    ll cur_d, u;
    tie(cur_d, u) = pq.top();
    pq.pop();
    if (cur_d > dist[u]) {
        continue;
    }
    FORE (elem, adj_s[u]) {
        ll v, w;
        tie(v, w) = elem;
        if (dist[v] > dist[u] + w) {
            dist[v] = dist[u] + w;
            pq.push({dist[v], v});
        }
    }
}

//--------------------------------------------------

struct Edge {
    ll s, t, cap = 0, cost = 0, flow = 0;
};

struct Dinic { // matrix
    ll n;
    vector<Edge> edges;
    vector<vector<ll>> adj, caps, flows, costs;
    vector<ll> lvl, ptr;
    queue<ll> q;

    Dinic(ll n, vector<Edge> &edges) :
        n(n), adj(n), edges(edges),
        caps(n, vector<ll>(n)),
        flows(n, vector<ll>(n)),
        costs(n, vector<ll>(n))
    {
        FORE (e, edges) {
            adj[e.s].pb(e.t);
            adj[e.t].pb(e.s);
            caps[e.s][e.t] = e.cap;
            costs[e.s][e.t] = e.cost;
        }
    }

    bool bfs(ll s, ll t) {
        lvl.assign(n, -1);
        lvl[s] = 0;
        q.push(s);
        while (!q.empty()) {
            ll v = q.front();
            q.pop();
            FORE (u, adj[v]) {
                if (lvl[u] != -1 || caps[v][u] <= flows[v][u]) {
                    continue;
                }
                lvl[u] = lvl[v] + 1;
                q.push(u);
            }
        }
        return lvl[t] != -1;
    }

    ll dfs(ll v, ll t, ll f) {
        if (v == t || f == 0) {
            return f;
        }
        for (ll &cid = ptr[v]; cid < sz(adj[v]); cid++) {
            ll u = adj[v][cid];
            if (lvl[v] + 1 != lvl[u] || caps[v][u] <= flows[v][u]) {
                continue;
            }
            ll tr = dfs(u, t, min(f, caps[v][u] - flows[v][u]));
            if (tr == 0) {
                continue;
            }
            flows[v][u] += tr;
            flows[u][v] -= tr;
            return tr;
        }
        return 0;
    }

    ll max_flow(ll s, ll t) {
        ll flow = 0;
        while (true) {
            if (!bfs(s, t)) {
                break;
            }
            ptr.assign(n, 0);
            while (ll pushed = dfs(s, t, LLONG_MAX)) {
                flow += pushed;
            }
        }
        return flow;
    }

    vector<pair<ll, ll>> min_cut(ll s) {
        bfs(s, -1);
        vector<pair<ll, ll>> cut;
        FORE (e, edges) {
            if (lvl[e.s] != -1 && lvl[e.t] == -1 && caps[e.s][e.t] > 0) {
                cut.pb({e.s, e.t});
            }
        }
        return cut;
    }

    void undo_flow(vector<ll> path, ll f) {
        FOB (i, 1, sz(path)) {
            flows[path[i - 1]][path[i]] -= f;
            flows[path[i]][path[i - 1]] += f;
            assert(flows[path[i - 1]][path[i]] >= 0);
            assert(flows[path[i]][path[i - 1]] >= 0);
            assert(flows[path[i - 1]][path[i]] <= caps[path[i - 1]][path[i]]);
            assert(flows[path[i]][path[i - 1]] <= caps[path[i]][path[i - 1]]);
        }
    }
};

struct Dinic { // edge list
    ll n;
    vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> lvl, ptr;
    queue<ll> q;

    Dinic(ll n, vector<Edge> &edges0) :
        n(n), adj(n), lvl(n), ptr(n) {
        ll i = 0;
        FORE (e, edges0) {
            edges.pb(e);
            edges.pb({e.t, e.s});
            adj[e.s].pb(i++);
            adj[e.t].pb(i++);
        }
    }

    bool bfs(ll s, ll t) {
        lvl.assign(n, -1);
        lvl[s] = 0;
        q.push(s);
        while (!q.empty()) {
            ll v = q.front();
            q.pop();
            FORE (e, adj[v]) {
                ll u = edges[e].t;
                if (lvl[u] != -1 || edges[e].cap <= edges[e].flow) continue;
                lvl[u] = lvl[v] + 1;
                q.push(u);
            }
        }
        return lvl[t] != -1;
    }

    ll dfs(ll v, ll t, ll f) {
        if (v == t || f == 0) return f;
        for (ll &cid = ptr[v]; cid < sz(adj[v]); cid++) {
            ll e = adj[v][cid];
            ll u = edges[e].t;
            if (lvl[v] + 1 != lvl[u]) continue;
            ll pushed = dfs(u, t, min(f, edges[e].cap - edges[e].flow));
            if (pushed) {
                edges[e].flow += pushed;
                edges[e ^ 1].flow -= pushed;
                return pushed;
            }
        }
        return 0;
    }

    ll max_flow(ll s, ll t) {
        ll flow = 0;
        while (bfs(s, t)) {
            ptr.assign(n, 0);
            while (ll pushed = dfs(s, t, INF)) {
                flow += pushed;
            }
        }
        return flow;
    }

    vector<pair<ll, ll>> min_cut(ll s) {
        bfs(s, n - 1);
        vector<pair<ll, ll>> cut;
        FORE (e,edges) {
            if (lvl[e.s] != -1 && lvl[e.t] == -1 && e.cap > 0) {
                cut.pb({e.s, e.t});
            }
        }
        return cut;
    }

    void undo_flow(vector<ll> path, ll f) {
        FOR (i, sz(path) - 1) {
            FORE (e, adj[path[i]]) {
                if (edges[e].t == path[i + 1]) {
                    edges[e].flow -= f;
                    edges[e ^ 1].flow += f;
                    assert(edges[e].flow <= edges[e].cap);
                    assert(edges[e ^ 1].flow <= edges[e ^ 1].cap);
                    break;
                }
            }
        }
    }
};

struct MinCostMaxFlow { // matrix
    ll n;
    vector<Edge> edges;
    vector<vector<ll>> adj, caps, flows, costs;
    vector<ll> vis, dist, pi;
    vector<pair<ll, ll>> par;
 
    MinCostMaxFlow(ll n, vector<Edge> &edges) :
        n(n), adj(n), edges(edges),
        caps(n, vector<ll>(n)),
        flows(n, vector<ll>(n)),
        costs(n, vector<ll>(n)),
        vis(n), dist(n), pi(n), par(n)
    {
        FORE (e, edges) {
            adj[e.s].pb(e.t);
            adj[e.t].pb(e.s);
            caps[e.s][e.t] = e.cap;
            costs[e.s][e.t] = e.cost;
        }
    }
 
    void path(ll s) {
        vis.assign(n, 0);
        dist.assign(n, INF);
        dist[s] = 0;
        ll di;
 
        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<pair<ll, ll>>> pq;
        pq.push({0, s});
        
        auto relax = [&](ll i, ll cap, ll cost, ll dir) {
            ll val = di - pi[i] + cost;
            if (cap && val < dist[i]) {
                dist[i] = val;
                par[i] = {s, dir};
                pq.push({dist[i], i});
            }
        };
 
        while (!pq.empty()) {
            s = pq.top().second;
            pq.pop();
            vis[s] = 1;
            di = dist[s] + pi[s];
            FORE (i, adj[s]) {
                if (!vis[i]) {
                    relax(i, caps[s][i] - flows[s][i], costs[s][i], 1);
                }
            }
            FORE (i, adj[s]) {
                if (!vis[i]) {
                    relax(i, flows[i][s], -costs[i][s], 0);
                }
            }
        }
 
        FOR (i, n) {
            pi[i] = min(pi[i] + dist[i], INF);
        }
    }
    
    pair<ll, ll> max_flow(ll s, ll t) {
        ll flow = 0, cost = 0;
        while (path(s), vis[t]) {
            ll fl = INF;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = p) {
                fl = min(fl, r ? caps[p][x] - flows[p][x] : flows[x][p]);
            }
            flow += fl;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = p) {
                if (r) flows[p][x] += fl;
                else flows[x][p] -= fl;
            }
        }
        FOR (i, n) {
            FOR (j, n) {
                cost += costs[i][j] * flows[i][j];
            }
        }
        return {flow, cost};
    }
 
    void set_pi(ll s) { // for negative costs
        pi.assign(n, INF);
        pi[s] = 0;
        ll it = n, ch = 1, v;
        while (ch-- && it--) {
            FOR (i, n) {
                if (pi[i] != INF) {
                    FORE (j, adj[i]) {
                        if (caps[i][j]) {
                            if ((v = pi[i] + costs[i][j]) < pi[j]) {
                                pi[j] = v;
                                ch = 1;
                            }
                        }
                    }
                }
            }
        }
        assert(it >= 0);
    }
};

struct MinCostMaxFlow { // edge list
    ll n, m;
    vector<Edge> edges;
    vector<vector<ll>> adj;
    vector<ll> dist, pi, vis;
    vector<pair<ll, ll>> par;

    MinCostMaxFlow(ll n, vector<Edge> &edges0) :
        n(n), m(sz(edges0)), adj(n),
        vis(n), dist(n), pi(n), par(n) {
        ll i = 0;
        FORE (e, edges0) {
            edges.pb(e);
            edges.pb({e.t, e.s});
            adj[e.s].pb(i++);
            adj[e.t].pb(i++);
        }
    }

    void path(ll s) {
        vis.assign(n, false);
        dist.assign(n, INF);
        dist[s] = 0;
        ll di;

        priority_queue<pair<ll, ll>, vector<pair<ll, ll>>, greater<>> pq;
        pq.push({0, s});

        auto relax = [&](ll t, ll e, ll cap, ll cost, ll dir) {
            ll val = di - pi[t] + cost;
            if (cap && val < dist[t]) {
                dist[t] = val;
                par[t] = {e, dir};
                pq.push({val, t});
            }
        };

        while (!pq.empty()) {
            s = pq.top().second;
            pq.pop();
            vis[s] = 1;
            di = dist[s] + pi[s];
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) {
                    relax(t, e, edges[e].cap - edges[e].flow, edges[e].cost, 1);
                }
            }
            FORE (e, adj[s]) {
                ll t = edges[e].t;
                if (!vis[t]) {
                    relax(t, e, edges[e ^ 1].flow, -edges[e ^ 1].cost, 0);
                }
            }
        }
    }

    pair<ll, ll> max_flow(ll s, ll t) {
        ll flow = 0, cost = 0;
        while (path(s), vis[t]) {
            ll f = INF;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                f = min(f, r ? edges[p].cap - edges[p].flow : edges[p ^ 1].flow);
            }
            flow += f;
            for (ll p, r, x = t; tie(p, r) = par[x], x != s; x = edges[p].s) {
                if (r) edges[p].flow += f;
                else edges[p ^ 1].flow -= f;
            }
        }
        FORE (e, edges) {
            cost += e.flow * e.cost;
        }
        return {flow, cost};
    }

    void set_pi(ll s) { // for negative costs
        pi.assign(n, INF);
        pi[s] = 0;
        ll it = n, ch = 1, v;
        while (ch-- && it--) {
            FOR (i, n) {
                if (pi[i] == INF) continue;
                FORE (e, adj[i]) {
                    if (edges[e].cap && (v = pi[i] + edges[e].cost) < pi[edges[e].t]) {
                        pi[edges[e].t] = v;
                        ch = 1;
                    }
                }
            }
        }
        assert(it >= 0);
    }
};

//--------------------------------------------------

struct DSU {
    ll cnt;
    vector<ll> e;
    DSU(ll n) { e = vector<ll>(n, -1); cnt = n; }
    void reset() { e = vector<ll>(sz(e), -1); cnt = sz(e); }
    ll get(int x) { return e[x] < 0 ? x : e[x] = get(e[x]); }
    bool same_set(ll a, ll b) { return get(a) == get(b); }
    ll size(ll x) { return -e[get(x)]; }
    ll count() { return cnt; }
    bool unite(ll x, ll y) {
        x = get(x), y = get(y);
        if (x == y) return false;
        if (e[x] > e[y]) swap(x, y);
        e[x] += e[y]; e[y] = x;
        cnt--;
        return true;
    }
};

//--------------------------------------------------

constexpr ll MOD = 1e9 + 7;
constexpr ll MAX_N = 1e3;

ll fact[MAX_N + 1];
ll inv_fact[MAX_N + 1];
ll inv[MAX_N + 1];
ll choose[MAX_N + 1][MAX_N + 1];
ll perm[MAX_N + 1][MAX_N + 1];

void init() {
    fact[0] = 1;
    inv_fact[0] = 1;
    inv[1] = 1;
    for (ll i = 1; i <= MAX_N; i++) {
        fact[i] = (fact[i - 1] * i) % MOD;
        if (i > 1) {
            inv[i] = (MOD - (MOD / i) * inv[MOD % i] % MOD) % MOD;
        }
        inv_fact[i] = (inv_fact[i - 1] * inv[i]) % MOD;
    }
    for (ll i = 0; i <= MAX_N; i++) {
        for (ll j = 0; j <= i; j++) {
            choose[i][j] = (fact[i] * inv_fact[j] % MOD) * inv_fact[i - j] % MOD;
        }
    }
    for (ll i = 0; i <= MAX_N; i++) {
        for (ll j = 0; j <= i; j++) {
            perm[i][j] = (fact[i] * inv_fact[i - j]) % MOD;
        }
    }
}

//--------------------------------------------------

void floyd_warshall(vector<vector<ll>> &dist) {
    ll n = sz(dist);
    FOR (k, n) {
        FOR (i, n) {
            FOR (j, n) {
                dist[i][j] = min(dist[i][j], dist[i][k] + dist[k][j]);
            }
        }
    }
}

void bellman_ford(ll v, vector<tuple<ll, ll, ll>> &edges, vector<ll> &dist) {
    ll n = sz(dist);
    FOR (i, n) {
        dist[i] = INF;
    }
    dist[v] = 0;
    FOR (i, n - 1) {
        for (auto [a, b, w] : edges) {
            if (dist[a] != INF && dist[a] + w < dist[b]) {
                dist[b] = dist[a] + w;
            }
        }
    }
}

//--------------------------------------------------

bool game(auto state, bool alice) {
    if (mem.find(state) != mem.end()) {
        return mem[state];
    }
    FORE (move, all_moves) {
        if (valid(move)) {
            change_state();
            if (!game(state, !alice)) {
                restore_state();
                mem[state] = true;
                return true;
            }
            restore_state();
        }
    }
    mem[state] = false;
    return false;
}

//--------------------------------------------------

ll gauss_jordan(vector<vector<ld>> &A, vector<ld> &b, vector<ld> &x) {
    ll n = A.size(), m = A[0].size();
    vector<vector<ld>> a(n, vector<ld>(m + 1));
    FOR(i, n) {
        FOR(j, m) {
            a[i][j] = A[i][j];
        }
        a[i][m] = b[i];
    }
    vector<ll> where(m, -1);
    for (ll col = 0, row = 0; col < m && row < n; col++) {
        ll sel = row;
        FOB (i, row, n) {
            if (abs(a[i][col]) > abs(a[sel][col])) {
                sel = i;
            }
        }
        if (abs(a[sel][col]) < EPS) {
            continue;
        }
        FOB (i, col, m + 1) {
            swap(a[sel][i], a[row][i]);
        }
        where[col] = row;
        FOR (i, n) {
            if (i != row) {
                ld c = a[i][col] / a[row][col];
                FOB (j, col, m + 1) {
                    a[i][j] -= a[row][j] * c;
                }
            }
        }
        row++;
    }
    x.assign(m, 0);
    FOR (i, m) {
        if (where[i] != -1) {
            x[i] = a[where[i]][m] / a[where[i]][i];
        }
    }
    FOR (i, n) {
        ld sum = 0;
        FOR (j, m) {
            sum += a[i][j] * x[j];
        }
        if (abs(sum - a[i][m]) > EPS) { // may need to change for modulo
            return 0;
        }
    }
    FOR (i, m) {
        if (where[i] == -1) {
            return INF;
        }
    }
    return 1;
}

int gauss_jordan_binary(
    vector<bitset<MAXN>> A,
    bitset<MAXN> &b,
    bitset<MAXN> &x,
    int n,
    int m
) {
    FOR (i, n) {
        A[i][m] = b[i];
    }

    vector<int> where(m, -1);
    for (int col = 0, row = 0; col < m && row < n; col++) {
        FOB (i, row, n) {
            if (A[i][col] != 0) {
                swap(A[i], A[row]);
                break;
            }
        }
        if (A[row][col] == 0) {
            continue;
        }
        where[col] = row;
        FOR (i, n) {
            if (i != row && A[i][col] != 0) {
                A[i] ^= A[row];
            }
        }
        row++;
    }

    x = bitset<MAXN>(0);
    FOR (i, m) {
        if (where[i] != -1) {
            x[i] = A[where[i]][m] / A[where[i]][i];
        }
    }
    FOR (i, n) {
        int sum = 0;
        FOR (j, m) {
            sum += A[i][j] * x[j];
        }
        if (sum != A[i][m]) {
            return 0;
        }
    }
    FOR (i, m) {
        if (where[i] == -1) {
            return INF;
        }
    }
    return 1;
}

//--------------------------------------------------

ll gcd(ll a, ll b) {
    if (a == 0) return b;
    return gcd(b % a, a);
}

// a * x + b * y = gcd(a, b)

pair<ll, ll> bezout(ll a, ll b) {
    if (a == 0) return {0, 1};
    auto [x, y] = bezout(b % a, a);
    return {y - (b / a) * x, x};
}

// x % m == a, x % n == b
// x % lcm(m, n) = -(a * v * n + b * u * m) / gcd(m, n)

ll crt(ll m, ll n, ll a, ll b) {
    ll g = gcd(m, n);
    if (a % g != b % g) return -1;
    ll lcm = m * n / g;
    auto [u, v] = bezout(m / g, n / g);
    ll k = (b - a) / g;
    ll x = (a + m * k * u) % lcm;
    if (x < 0) x += lcm;
    return x;
}

//--------------------------------------------------

struct LCA_Tree {
    vector<vector<ll>> parent, adj;
    vector<ll> pre, post, depth;
    ll n, timer;

    LCA_Tree(ll &n0, vector<vector<ll>> &adj0) {
        n = n0;
        timer = 0;
        pre = vector<ll>(n), post = pre, depth = pre;
        parent = vector<vector<ll>>(n, vector<ll>(30));
        adj = adj0;
        dfs(0, 0, 0);
        gen();
    }

    void dfs(ll node, ll par, ll d) {
        pre[node] = timer++;
        depth[node] = d;
        parent[node][0] = par;
        FORE (child, adj[node]) {
            if (child != par) {
                dfs(child, node, d + 1);
            }
        }
        post[node] = timer++;
    }

    void gen() {
        FOR (i, 29) {
            FOR (j, n) {
                parent[j][i + 1] = parent[parent[j][i]][i];
            }
        }
    }

    bool is_anc(ll u, ll v) {
        return pre[u] <= pre[v] && post[u] >= post[v];
    }

    ll lca(ll u, ll v) {
        if (is_anc(u, v)) return u;
        if (is_anc(v, u)) return v;
        FORR (i, 30) {
            if (!is_anc(parent[u][i], v)) {
                u = parent[u][i];
            }
        }
        return parent[u][0];
    }

    ll dist(ll u, ll v) {
        return depth[u] + depth[v] - 2 * depth[lca(u, v)];
    }

    bool disjoint(vector<pair<ll, ll>> paths) {
        vector<pair<ll, ll>> p;
        FORE (path, paths) {
            ll u, v;
            tie(u, v) = path;
            ll w = lca(u, v);
            p.pb({w, u});
            p.pb({w, v});
        }
        FOR (i, sz(p)) {
            FOR (j, i - i % 2) {
                if (!(lca(p[i].second, p[j].first) != p[j].first ||
                    lca(p[j].second, p[i].first) != p[i].first))
                {
                    return false;
                }
            }
        }
        return true;
    }
};

//--------------------------------------------------

pair<ll, ll> manacher(str &s) {
    str t = "$#";
    FORE (c, s) {
        t += c;
        t += '#';
    }

    ll n = sz(t);
    ll center = 0, max_rad = -1, rad;
    vector<ll> p(n);
    FOR (i, n) {
        if (i <= max_rad) {
            rad = min(p[2 * center - i], max_rad - i);
        } else {
            rad = 0;
        }
        while (i - rad - 1 >= 0 && i + rad + 1 < n && t[i - rad - 1] == t[i + rad + 1]) {
            rad++;
        }
        p[i] = rad;
        if (i + rad > max_rad) {
            center = i;
            max_rad = i + rad;
        }
    }

    ll len = 0, idx = 0;
    FOR (i, n) {
        if (p[i] > len) {
            len = p[i];
            idx = i;
        }
    }

    return {len, (idx - len) / 2};
}

//--------------------------------------------------

struct Matrix {
    vector<vector<ll>> mat;
    ll n, m;

    Matrix(ll n, ll m) : n(n), m(m) {
        mat.resize(n, vector<ll>(m));
    }

    Matrix operator*(const Matrix &other) const {
        Matrix rv(n, other.m);
        FOR(i, n) {
            FOR(j, other.m) {
                FOR(k, m) {
                    rv.mat[i][j] += mat[i][k] * other.mat[k][j];
                    rv.mat[i][j] %= MOD;
                }
            }
        }
        return rv;
    }

    Matrix operator^(ll p) const {
        Matrix rv(n, n);
        FOR(i, n) {
            rv.mat[i][i] = 1;
        }
        Matrix a = *this;
        while (p) {
            if (p & 1) {
                rv = rv * a;
            }
            a = a * a;
            p >>= 1;
        }
        return rv;
    }
};

//--------------------------------------------------

ll pow(ll x, ll p) {
    ll rv = 1;
    while(p) {
        if(p & 1) rv *= x;
        x *= x;
        p >>= 1;
    }
    return rv;
}

//--------------------------------------------------

vector<vector<ll>> scc(vector<vector<ll>> adj) {
    ll n = sz(adj);
    vector<ll> order;
    vector<bool> vis(n);
    function<void(ll)> dfs = [&](ll u) {
        vis[u] = true;
        FORE(v, adj[u]) {
            if (!vis[v]) {
                dfs(v);
            }
        }
        order.pb(u);
    };
    FOR(i, n) {
        if (!vis[i]) {
            dfs(i);
        }
    }
    vector<vector<ll>> adjt(n);
    FOR(i, n) {
        FORE(j, adj[i]) {
            adjt[j].pb(i);
        }
    }
    vector<vector<ll>> sccs;
    vis.assign(n, false);
    function<void(ll, vector<ll> &)> dfs2 = [&](ll u, vector<ll> &scc) {
        vis[u] = true;
        scc.pb(u);
        FORE(v, adjt[u]) {
            if (!vis[v]) {
                dfs2(v, scc);
            }
        }
    };
    FORR(i, n) {
        if (!vis[order[i]]) {
            vector<ll> scc;
            dfs2(order[i], scc);
            sccs.pb(scc);
        }
    }
    return sccs;
}

//--------------------------------------------------

struct SegTree {
    ll n;
    vector<ll> data, lazy;
    SegTree (ll n) :
        n(n),
        data(4 * n, 0),
        lazy(4 * n, 0) {}
    void update(ll lo, ll hi, ll val, ll i = 1, ll l = 0, ll r = -1) { // [lo, hi)
        if (r == -1) r = n;
        if (lazy[i] != 0) {
            data[i] += (r - l) * lazy[i];
            if (r - l > 1) {
                lazy[2 * i] += lazy[i];
                lazy[2 * i + 1] += lazy[i];
            }
            lazy[i] = 0;
        }
        if (lo <= l && r <= hi) {
            data[i] += (r - l) * val;
            if (r - l > 1) {
                lazy[2 * i] += val;
                lazy[2 * i + 1] += val;
            }
            return;
        }
        if (r <= lo || hi <= l) return;
        ll m = (l + r) / 2;
        update(lo, hi, val, 2 * i, l, m);
        update(lo, hi, val, 2 * i + 1, m, r);
        data[i] = data[2 * i] + data[2 * i + 1];
    }
    ll query(ll lo, ll hi, ll i = 1, ll l = 0, ll r = -1) {
        if (r == -1) r = n;
        if (lazy[i] != 0) {
            data[i] += (r - l) * lazy[i];
            if (r - l > 1) {
                lazy[2 * i] += lazy[i];
                lazy[2 * i + 1] += lazy[i];
            }
            lazy[i] = 0;
        }
        if (lo <= l && r <= hi) return data[i];
        if (r <= lo || hi <= l) return 0;
        ll m = (l + r) / 2;
        return query(lo, hi, 2 * i, l, m) + query(lo, hi, 2 * i + 1, m, r);
    }
};

//--------------------------------------------------

struct Vertex { // persistent segtree, sum
    Vertex *l, *r;
    ll sum;

    Vertex(ll val) : l(nullptr), r(nullptr), sum(val) {}
    Vertex(Vertex *l, Vertex *r) : l(l), r(r), sum(0) {
        if (l) sum += l->sum;
        if (r) sum += r->sum;
    }
};

Vertex* build(vector<ll> &a, ll tl, ll tr) { // [tl, tr]
    if (tl == tr) return new Vertex(a[tl]);
    ll tm = (tl + tr) / 2;
    return new Vertex(build(a, tl, tm), build(a, tm + 1, tr));
}

ll get_sum(Vertex* v, ll tl, ll tr, ll l, ll r) { // [tl, tr] = [0, n - 1], [l, r]
    if (l > r) return 0;
    if (l == tl && tr == r) return v->sum;
    ll tm = (tl + tr) / 2;
    return get_sum(v->l, tl, tm, l, min(r, tm))
         + get_sum(v->r, tm + 1, tr, max(l, tm + 1), r);
}

Vertex* update(Vertex* v, ll tl, ll tr, ll pos, ll new_val) { // [tl, tr] = [0, n - 1]
    if (tl == tr) return new Vertex(new_val);
    ll tm = (tl + tr) / 2;
    if (pos <= tm) return new Vertex(update(v->l, tl, tm, pos, new_val), v->r);
    else return new Vertex(v->l, update(v->r, tm + 1, tr, pos, new_val));
}

//--------------------------------------------------

ld shoelace(vector<pair<ld, ld>> &v) {
    ld area = 0;
    FOR (i, sz(v)) {
        area += (v[i].first * v[(i + 1) % sz(v)].second) -
            (v[i].second * v[(i + 1) % sz(v)].first);
    }
    return abs(area) / 2;
}

//--------------------------------------------------

struct SuffixTree {
    str s; // input string for which the suffix tree is being built
    vector<vector<ll>> tree; // array of transitions (state, letter)
    // left... and right boundaries of the substring of s which correspond to incoming edge
    // parent of the node
    // suffix link
    vector<ll> lo, hi, par, link;
    // maximum possible number of nodes in suffix tree
    // number of letters in the alphabet
    ll n, alpha;
    // the node of the current suffix (if we're mid-edge, the lower node of the edge)
    // position in the string which corresponds to the position on the edge (between lo[cur_node] and hi[cur_node], inclusive)
    // the number of nodes
    // the current character in the string
    ll cur_node, cur_pos, cur_size, cur_char;

    SuffixTree(str &s_in, ll alpha = 27) : s(s_in), alpha(alpha) {
        s += '$';
        n = sz(s) * 2 + 2;
        tree = vector<vector<ll>>(n, vector<ll>(alpha, -1));
        lo = vector<ll>(n);
        hi = vector<ll>(n, sz(s) - 1);
        par = vector<ll>(n);
        link = vector<ll>(n);
        cur_size = 2;
        cur_node = 0;
        cur_pos = 0;
        // initialize data for the root of the tree
        link[0] = 1;
        lo[0] = -1;
        hi[0] = -1;
        lo[1] = -1;
        hi[1] = -1;
        tree[1] = vector<ll>(alpha, 0);
        // add the text to the tree, letter by letter
        for (cur_char = 0; cur_char < sz(s); ++cur_char) {
            add_char(char_to_index(s[cur_char]));
        }
    }

    ll char_to_index(ch c) {
        if (c == '$') {
            return 0;
        } else {
            return c - 'a' + 1;
        }
    }

    // add character c to the tree
    void add_char(ll c) {
        // we'll return here after each transition to the suffix (and will add character again)
        suff:;
        // check whether we're still within the boundaries of the current edge
        if (hi[cur_node] < cur_pos) {
            // if we're not, find the next edge. If it doesn't exist, create a leaf and add it to the tree
            if (tree[cur_node][c] == -1) {
                tree[cur_node][c] = cur_size;
                lo[cur_size] = cur_char;
                par[cur_size++] = cur_node;
                cur_node = link[cur_node];
                cur_pos = hi[cur_node] + 1;
                goto suff;
            }
            cur_node = tree[cur_node][c];
            cur_pos = lo[cur_node];
        } // otherwise just proceed to the next edge
        if (cur_pos == -1 || c == char_to_index(s[cur_pos])) {
            cur_pos++; // if the letter on the edge equal c, go down that edge
        } else { 
            // otherwise split the edge in two with middle in node cur_size
            lo[cur_size] = lo[cur_node];
            hi[cur_size] = cur_pos - 1;
            par[cur_size] = par[cur_node];
            tree[cur_size][char_to_index(s[cur_pos])] = cur_node;
            // add leaf cur_size+1. It corresponds to transition through c.
            tree[cur_size][c] = cur_size + 1;
            lo[cur_size + 1] = cur_char;
            par[cur_size + 1] = cur_size;
            // update info for the current node - remember to mark cur_size as parent of cur_node
            lo[cur_node] = cur_pos;
            par[cur_node] = cur_size;
            tree[par[cur_size]][char_to_index(s[lo[cur_size]])] = cur_size;
            cur_size += 2;
            // prepare for descent
            // cur_pos will mark where are we in the current suffix
            cur_node = link[par[cur_size - 2]];
            cur_pos = lo[cur_size - 2];
            // while the current suffix is not over, descend
            while (cur_pos <= hi[cur_size - 2]) {
                cur_node = tree[cur_node][char_to_index(s[cur_pos])];
                cur_pos += hi[cur_node] - lo[cur_node] + 1;
            }
            // if we're in a node, add a suffix link to it, otherwise add the link to cur_size
            // (we'll create cur_size on next iteration).
            if (cur_pos == hi[cur_size - 2] + 1) {
                link[cur_size - 2] = cur_node;
            } else {
                link[cur_size - 2] = cur_size;
            } 
            // add cur_pos to the new edge and return to add letter to suffix
            cur_pos = hi[cur_node] - (cur_pos - hi[cur_size - 2]) + 2;
            goto suff;
        }
    }

    void print() {
        FOR (i, cur_size) {
            cout << i << ':' << lo[i] << ' ' << hi[i] << ' ' << par[i] << ' ' << link[i] << " " << '\n';
            FOR (j, alpha) {
                if (tree[i][j] != -1) {
                    if (j == 0) {
                        cout << "$ ";
                    } else {
                        cout << (char)('a' + j - 1) << ' ';
                    }
                    cout << tree[i][j] << '\n';
                }
            }
        }
    }
};

ll gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth, ll v = 0, ll d = 0) {
    depth[v] = d;
    ll rv = 0;
    FOR (i, st.alpha) {
        if (st.tree[v][i] != -1) {
            rv += gen_tree(st, leafs, depth, st.tree[v][i], d + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1);
        }
    }
    if (rv == 0) {
        rv = 1;
    }
    leafs[v] = rv;
    return rv;
}

void gen_tree(SuffixTree &st, vector<ll> &leafs, vector<ll> &depth) {
    vector<ll> in(st.cur_size);
    queue<ll> depth_q, leaf_q;
    depth_q.push(0);
    while (!depth_q.empty()) {
        ll v = depth_q.front();
        depth_q.pop();
        bool is_leaf = true;
        FOR (i, st.alpha) {
            if (st.tree[v][i] != -1) {
                depth[st.tree[v][i]] = depth[v] + st.hi[st.tree[v][i]] - st.lo[st.tree[v][i]] + 1;
                depth_q.push(st.tree[v][i]);
                in[v]++;
                is_leaf = false;
            }
        }
        if (is_leaf) {
            leafs[v] = 1;
            leaf_q.push(v);
        }
    }
    while (!leaf_q.empty()) {
        ll v = leaf_q.front();
        leaf_q.pop();
        if (v != 0) {
            leafs[st.par[v]] += leafs[v];
            in[st.par[v]]--;
            if (in[st.par[v]] == 0) {
                leaf_q.push(st.par[v]);
            }
        }
    }
}

int main() {
    ios_base::sync_with_stdio(false);
    cin.tie(nullptr);

    str s;
    cin >> s;
    SuffixTree st(s);
    vector<int> leafs(st.cur_size), depth(st.cur_size);
    gen_tree(st, leafs, depth);
    int k;
    cin >> k;

    while (k--) {
        str t;
        cin >> t;

        int i = 0, v = 0;
        if (st.tree[0][st.char_to_index(t[0])] == -1) {
            cout << 0 << '\n';
            continue;
        } else {
            v = st.tree[0][st.char_to_index(t[0])];
        }

        bool ok = true;
        int idx = 0;
        while (i < sz(t)) {
            int j = st.lo[v];
            while (j <= st.hi[v] && i < sz(t) && t[i] == s[j]) {
                i++;
                j++;
            }
            if (i == sz(t)) {
                idx = j - sz(t) + 1;
                break;
            }
            if (j > st.hi[v]) {
                if (st.tree[v][st.char_to_index(t[i])] == -1) {
                    ok = false;
                    break;
                } else {
                    v = st.tree[v][st.char_to_index(t[i])];
                }
            } else {
                ok = false;
                break;
            }
        }
    }

    return 0;
}

//--------------------------------------------------

#include <ext/pb_ds/assoc_container.hpp>

using namespace __gnu_pbds;

template<class T> using Tree = tree<T, null_type, less<T>, rb_tree_tag, tree_order_statistics_node_update>;

//--------------------------------------------------

void make_clockwise(vector<pair<ld, ld>> &points) {
    pair<ld, ld> center = mp(0, 0);
    FORE (p, points) {
        center.first += p.first;
        center.second += p.second;
    }
    center.first /= sz(points);
    center.second /= sz(points);
    sort(all(points), [center](pair<ld, ld> &p1, pair<ld, ld> &p2) {
        return atan2(p1.second - center.second, p1.first - center.first) <
               atan2(p2.second - center.second, p2.first - center.first);
    });
}

bool in_triangle(pair<ld, ld> &point, vector<pair<ld, ld>> &triangle) {
    vector<ld> d(3);
    FOR (i, 3) {
        auto &p1 = triangle[i];
        auto &p2 = triangle[(i + 1) % 3];
        d[i] = (p2.first - p1.first) * (point.second - p1.second) -
            (p2.second - p1.second) * (point.first - p1.first);
    }
    return (d[0] >= 0 && d[1] >= 0 && d[2] >= 0) || (d[0] <= 0 && d[1] <= 0 && d[2] <= 0);
}

//--------------------------------------------------

constexpr ll ALPHA = 26;

struct Trie {
    ch c;
    bool ending = false;
    vector<Trie*> children = vector<Trie*>(ALPHA, nullptr);

    Trie(ch c_) : c(c_) {}

    void insert(ll i, str &s) {
        if (i == sz(s)) {
            ending = true;
            return;
        }
        ll si = s[i] - 'a';
        if (children[si] == nullptr) {
            children[si] = new Trie(s[i]);
        }
        children[si]->insert(i + 1, s);
    }
};